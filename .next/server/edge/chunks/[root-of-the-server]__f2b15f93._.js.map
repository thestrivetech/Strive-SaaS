{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["// middleware.ts\r\nimport { NextResponse } from 'next/server';\r\nimport type { NextRequest } from 'next/server';\r\nimport { Ratelimit } from '@upstash/ratelimit';\r\nimport { Redis } from '@upstash/redis';\r\n\r\n// Initialize Redis-backed rate limiter\r\n// This limits each IP to 10 requests per minute\r\nconst ratelimit = new Ratelimit({\r\n  redis: Redis.fromEnv(),\r\n  limiter: Ratelimit.slidingWindow(10, '1 m'), // 10 requests per 1 minute\r\n  analytics: true, // Track usage in Upstash dashboard\r\n  prefix: '@upstash/ratelimit',\r\n});\r\n\r\nexport async function middleware(request: NextRequest) {\r\n  // Only apply rate limiting to API routes\r\n  if (!request.nextUrl.pathname.startsWith('/api/')) {\r\n    return NextResponse.next();\r\n  }\r\n\r\n  // Get IP address for rate limiting\r\n  const ip = request.headers.get('x-forwarded-for') ?? \r\n             request.headers.get('x-real-ip') ?? \r\n             'anonymous';\r\n\r\n  try {\r\n    // Check rate limit\r\n    const { success, limit, reset, remaining } = await ratelimit.limit(\r\n      `ratelimit_${ip}`\r\n    );\r\n\r\n    // If rate limit exceeded\r\n    if (!success) {\r\n      const now = Date.now();\r\n      const retryAfter = Math.floor((reset - now) / 1000);\r\n\r\n      return new NextResponse(\r\n        JSON.stringify({\r\n          error: 'Too Many Requests',\r\n          message: 'You have exceeded the rate limit. Please try again later.',\r\n          retryAfter: retryAfter,\r\n        }),\r\n        {\r\n          status: 429,\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            'X-RateLimit-Limit': limit.toString(),\r\n            'X-RateLimit-Remaining': remaining.toString(),\r\n            'X-RateLimit-Reset': new Date(reset).toISOString(),\r\n            'Retry-After': retryAfter.toString(),\r\n          },\r\n        }\r\n      );\r\n    }\r\n\r\n    // Add rate limit headers to response\r\n    const response = NextResponse.next();\r\n    response.headers.set('X-RateLimit-Limit', limit.toString());\r\n    response.headers.set('X-RateLimit-Remaining', remaining.toString());\r\n    response.headers.set('X-RateLimit-Reset', new Date(reset).toISOString());\r\n\r\n    return response;\r\n  } catch (error) {\r\n    // If rate limiting fails, allow the request but log the error\r\n    console.error('Rate limiting error:', error);\r\n    return NextResponse.next();\r\n  }\r\n}\r\n\r\n// Configure which routes use this middleware\r\nexport const config = {\r\n  matcher: [\r\n    '/api/:path*', // Apply to all API routes\r\n  ],\r\n};"],"names":[],"mappings":"AAAA,gBAAgB;;;;;;;AAChB;AAAA;AAEA;AACA;;;;AAEA,uCAAuC;AACvC,gDAAgD;AAChD,MAAM,YAAY,IAAI,4KAAS,CAAC;IAC9B,OAAO,8KAAK,CAAC,OAAO;IACpB,SAAS,4KAAS,CAAC,aAAa,CAAC,IAAI;IACrC,WAAW;IACX,QAAQ;AACV;AAEO,eAAe,WAAW,OAAoB;IACnD,yCAAyC;IACzC,IAAI,CAAC,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;QACjD,OAAO,gMAAY,CAAC,IAAI;IAC1B;IAEA,mCAAmC;IACnC,MAAM,KAAK,QAAQ,OAAO,CAAC,GAAG,CAAC,sBACpB,QAAQ,OAAO,CAAC,GAAG,CAAC,gBACpB;IAEX,IAAI;QACF,mBAAmB;QACnB,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,MAAM,UAAU,KAAK,CAChE,CAAC,UAAU,EAAE,IAAI;QAGnB,yBAAyB;QACzB,IAAI,CAAC,SAAS;YACZ,MAAM,MAAM,KAAK,GAAG;YACpB,MAAM,aAAa,KAAK,KAAK,CAAC,CAAC,QAAQ,GAAG,IAAI;YAE9C,OAAO,IAAI,gMAAY,CACrB,KAAK,SAAS,CAAC;gBACb,OAAO;gBACP,SAAS;gBACT,YAAY;YACd,IACA;gBACE,QAAQ;gBACR,SAAS;oBACP,gBAAgB;oBAChB,qBAAqB,MAAM,QAAQ;oBACnC,yBAAyB,UAAU,QAAQ;oBAC3C,qBAAqB,IAAI,KAAK,OAAO,WAAW;oBAChD,eAAe,WAAW,QAAQ;gBACpC;YACF;QAEJ;QAEA,qCAAqC;QACrC,MAAM,WAAW,gMAAY,CAAC,IAAI;QAClC,SAAS,OAAO,CAAC,GAAG,CAAC,qBAAqB,MAAM,QAAQ;QACxD,SAAS,OAAO,CAAC,GAAG,CAAC,yBAAyB,UAAU,QAAQ;QAChE,SAAS,OAAO,CAAC,GAAG,CAAC,qBAAqB,IAAI,KAAK,OAAO,WAAW;QAErE,OAAO;IACT,EAAE,OAAO,OAAO;QACd,8DAA8D;QAC9D,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,gMAAY,CAAC,IAAI;IAC1B;AACF;AAGO,MAAM,SAAS;IACpB,SAAS;QACP;KACD;AACH"}}]
}