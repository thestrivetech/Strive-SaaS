{
  "name": "campaign-budget-optimizer-v1",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 6 * * *"
            }
          ]
        }
      },
      "id": "daily-trigger",
      "name": "Daily at 6 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [250, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/campaigns",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "apikey", "value": "={{ $env.SUPABASE_SERVICE_KEY }}"},
            {"name": "Authorization", "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"}
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {"name": "status", "value": "eq.active"},
            {"name": "select", "value": "id,organization_id,name,platform,budget,spend,revenue,roi,conversions"}
          ]
        }
      },
      "id": "fetch-campaigns",
      "name": "Fetch Active Campaigns",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/campaign_metrics",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "apikey", "value": "={{ $env.SUPABASE_SERVICE_KEY }}"},
            {"name": "Authorization", "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"}
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {"name": "date", "value": "=gte.{{ new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] }}"},
            {"name": "select", "value": "campaign_id,date,spend,revenue,roi,conversions"},
            {"name": "order", "value": "date.desc"}
          ]
        }
      },
      "id": "fetch-historical",
      "name": "Fetch 30-Day History",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 500]
    },
    {
      "parameters": {
        "jsCode": "// ===============================================\n// BUDGET OPTIMIZATION ENGINE\n// Machine Learning-based budget allocation\n// ===============================================\n\nconst campaigns = $('Fetch Active Campaigns').all().map(i => i.json).flat();\nconst historicalMetrics = $('Fetch 30-Day History').all().map(i => i.json).flat();\n\nif (campaigns.length === 0) {\n  return [{\n    json: {\n      message: 'No active campaigns to optimize',\n      recommendations: []\n    }\n  }];\n}\n\n// ===============================================\n// STEP 1: CALCULATE HISTORICAL PERFORMANCE\n// ===============================================\nfunction calculateHistoricalPerformance(campaignId, metrics) {\n  const campaignMetrics = metrics.filter(m => m.campaign_id === campaignId);\n  \n  if (campaignMetrics.length === 0) {\n    return {\n      avg_roi: 0,\n      roi_trend: 0,\n      roi_volatility: 0,\n      total_spend: 0,\n      total_revenue: 0,\n      conversion_rate: 0,\n      days_with_data: 0,\n      confidence: 0\n    };\n  }\n  \n  // Calculate averages\n  const avgROI = campaignMetrics.reduce((sum, m) => sum + parseFloat(m.roi || 0), 0) / campaignMetrics.length;\n  const totalSpend = campaignMetrics.reduce((sum, m) => sum + parseFloat(m.spend || 0), 0);\n  const totalRevenue = campaignMetrics.reduce((sum, m) => sum + parseFloat(m.revenue || 0), 0);\n  const totalConversions = campaignMetrics.reduce((sum, m) => sum + parseInt(m.conversions || 0), 0);\n  \n  // Calculate trend (first half vs second half)\n  const midpoint = Math.floor(campaignMetrics.length / 2);\n  const firstHalf = campaignMetrics.slice(0, midpoint);\n  const secondHalf = campaignMetrics.slice(midpoint);\n  \n  const firstHalfROI = firstHalf.reduce((sum, m) => sum + parseFloat(m.roi || 0), 0) / firstHalf.length;\n  const secondHalfROI = secondHalf.reduce((sum, m) => sum + parseFloat(m.roi || 0), 0) / secondHalf.length;\n  const roiTrend = firstHalfROI > 0 ? ((secondHalfROI - firstHalfROI) / firstHalfROI) : 0;\n  \n  // Calculate volatility (standard deviation)\n  const mean = avgROI;\n  const squaredDiffs = campaignMetrics.map(m => Math.pow(parseFloat(m.roi || 0) - mean, 2));\n  const variance = squaredDiffs.reduce((sum, d) => sum + d, 0) / campaignMetrics.length;\n  const volatility = Math.sqrt(variance);\n  \n  // Confidence based on data availability and consistency\n  const dataQuality = Math.min(campaignMetrics.length / 30, 1); // More data = higher confidence\n  const consistencyScore = volatility < 0.5 ? 1 : volatility < 1 ? 0.8 : 0.6; // Lower volatility = higher confidence\n  const confidence = dataQuality * consistencyScore;\n  \n  return {\n    avg_roi: avgROI,\n    roi_trend: roiTrend,\n    roi_volatility: volatility,\n    total_spend: totalSpend,\n    total_revenue: totalRevenue,\n    conversion_rate: totalSpend > 0 ? (totalConversions / (totalSpend / 100)) : 0, // conversions per $100\n    days_with_data: campaignMetrics.length,\n    confidence: confidence\n  };\n}\n\n// ===============================================\n// STEP 2: PREDICT FUTURE ROI\n// ===============================================\nfunction predictFutureROI(campaign, historical) {\n  // Simple predictive model:\n  // Predicted ROI = Historical Average + (Trend * Weight) - (Volatility Penalty)\n  \n  const trendWeight = 0.3; // 30% weight on recent trend\n  const volatilityPenalty = historical.roi_volatility * 0.1; // Penalize volatile campaigns\n  \n  let predictedROI = historical.avg_roi * (1 + historical.roi_trend * trendWeight) - volatilityPenalty;\n  \n  // Apply platform-specific multipliers\n  const platformMultipliers = {\n    'google_ads': 1.05, // Slight preference for search\n    'facebook': 1.0,\n    'linkedin': 0.95,\n    'email': 1.1, // Email typically has good ROI\n    'organic': 1.15 // Organic has best ROI but limited budget impact\n  };\n  \n  const multiplier = platformMultipliers[campaign.platform] || 1.0;\n  predictedROI *= multiplier;\n  \n  return Math.max(0, predictedROI); // Ensure non-negative\n}\n\n// ===============================================\n// STEP 3: OPTIMIZE BUDGET ALLOCATION\n// ===============================================\nfunction optimizeBudgetAllocation(campaigns, historicalData, totalBudget) {\n  // Calculate performance metrics for each campaign\n  const campaignPerformance = campaigns.map(campaign => {\n    const historical = calculateHistoricalPerformance(campaign.id, historicalData);\n    const predictedROI = predictFutureROI(campaign, historical);\n    \n    return {\n      campaign_id: campaign.id,\n      campaign_name: campaign.name,\n      platform: campaign.platform,\n      current_budget: parseFloat(campaign.budget || 0),\n      current_spend: parseFloat(campaign.spend || 0),\n      current_roi: parseFloat(campaign.roi || 0),\n      historical_performance: historical,\n      predicted_roi: predictedROI,\n      efficiency_score: predictedROI * historical.confidence,\n      scalability_potential: calculateScalabilityPotential(campaign, historical)\n    };\n  });\n  \n  // Sort by efficiency score (ROI * Confidence)\n  campaignPerformance.sort((a, b) => b.efficiency_score - a.efficiency_score);\n  \n  // Allocate budget proportionally to efficiency score\n  const totalEfficiency = campaignPerformance.reduce((sum, c) => sum + c.efficiency_score, 0);\n  \n  if (totalEfficiency === 0) {\n    // If no efficiency data, distribute equally\n    const equalBudget = totalBudget / campaigns.length;\n    return campaignPerformance.map(c => ({\n      ...c,\n      recommended_budget: equalBudget\n    }));\n  }\n  \n  // Calculate recommended budgets\n  const optimized = campaignPerformance.map(c => {\n    // Base allocation on efficiency\n    let recommendedBudget = (c.efficiency_score / totalEfficiency) * totalBudget;\n    \n    // Apply constraints\n    const minBudget = 100; // Minimum $100 per campaign\n    const maxBudget = totalBudget * 0.4; // No campaign should get more than 40% of total\n    \n    // Apply scalability limits\n    const currentBudget = c.current_budget || 1000;\n    const maxIncrease = currentBudget * 2; // Don't increase by more than 100%\n    const maxDecrease = currentBudget * 0.5; // Don't decrease by more than 50%\n    \n    recommendedBudget = Math.max(minBudget, Math.min(maxBudget, recommendedBudget));\n    recommendedBudget = Math.max(maxDecrease, Math.min(maxIncrease, recommendedBudget));\n    \n    return {\n      ...c,\n      recommended_budget: Math.round(recommendedBudget * 100) / 100\n    };\n  });\n  \n  // Normalize to ensure total equals budget\n  const allocatedTotal = optimized.reduce((sum, c) => sum + c.recommended_budget, 0);\n  const normalizationFactor = totalBudget / allocatedTotal;\n  \n  return optimized.map(c => ({\n    ...c,\n    recommended_budget: Math.round(c.recommended_budget * normalizationFactor * 100) / 100\n  }));\n}\n\nfunction calculateScalabilityPotential(campaign, historical) {\n  // High scalability = good ROI + low volatility + positive trend\n  const roiScore = Math.min(historical.avg_roi / 3, 1); // ROI of 3+ = max score\n  const stabilityScore = Math.max(0, 1 - historical.roi_volatility / 2);\n  const trendScore = Math.max(0, Math.min(1, (historical.roi_trend + 0.5) / 1.5)); // -0.5 to 1 mapped to 0-1\n  \n  return (roiScore * 0.5 + stabilityScore * 0.3 + trendScore * 0.2);\n}\n\n// ===============================================\n// STEP 4: GENERATE RECOMMENDATIONS\n// ===============================================\nfunction generateRecommendations(optimized) {\n  return optimized.map(campaign => {\n    const budgetChange = campaign.recommended_budget - campaign.current_budget;\n    const changePercentage = campaign.current_budget > 0\n      ? (budgetChange / campaign.current_budget * 100)\n      : 0;\n    \n    // Determine priority\n    let priority = 'medium';\n    if (Math.abs(changePercentage) > 30 || campaign.current_roi < 1.0) {\n      priority = 'high';\n    }\n    if (campaign.current_roi < 0.5) {\n      priority = 'critical';\n    }\n    \n    // Generate reasoning\n    let reasoning = '';\n    if (budgetChange > 0) {\n      reasoning = `Strong performance (ROI: ${campaign.predicted_roi.toFixed(2)}) with ${(campaign.scalability_potential * 100).toFixed(0)}% scalability potential. `;\n      reasoning += `Projected to generate $${(budgetChange * campaign.predicted_roi).toFixed(2)} additional revenue.`;\n    } else if (budgetChange < 0) {\n      reasoning = `Underperforming (ROI: ${campaign.current_roi.toFixed(2)}). `;\n      reasoning += campaign.historical_performance.roi_trend < 0\n        ? 'Declining performance trend detected. '\n        : 'Reallocate to higher-performing campaigns.';\n    } else {\n      reasoning = 'Optimal budget allocation. Maintain current spending.';\n    }\n    \n    // Calculate expected impact\n    const expectedAdditionalRevenue = budgetChange * campaign.predicted_roi;\n    const expectedROIImprovement = campaign.predicted_roi - campaign.current_roi;\n    \n    return {\n      campaign_id: campaign.campaign_id,\n      campaign_name: campaign.campaign_name,\n      platform: campaign.platform,\n      current_budget: campaign.current_budget,\n      current_spend: campaign.current_spend,\n      current_roi: campaign.current_roi,\n      recommended_budget: campaign.recommended_budget,\n      budget_change: Math.round(budgetChange * 100) / 100,\n      change_percentage: Math.round(changePercentage * 10) / 10,\n      priority: priority,\n      reasoning: reasoning,\n      predicted_roi: Math.round(campaign.predicted_roi * 100) / 100,\n      confidence: Math.round(campaign.historical_performance.confidence * 100) / 100,\n      expected_additional_revenue: Math.round(expectedAdditionalRevenue * 100) / 100,\n      expected_roi_improvement: Math.round(expectedROIImprovement * 100) / 100,\n      scalability_score: Math.round(campaign.scalability_potential * 100),\n      data_quality: {\n        days_analyzed: campaign.historical_performance.days_with_data,\n        volatility: Math.round(campaign.historical_performance.roi_volatility * 100) / 100\n      }\n    };\n  });\n}\n\n// ===============================================\n// EXECUTE OPTIMIZATION\n// ===============================================\n\n// Calculate total available budget across all organizations\n// In production, this should be per-organization\nconst totalBudget = campaigns.reduce((sum, c) => sum + parseFloat(c.budget || 0), 0);\n\nconst optimizedAllocations = optimizeBudgetAllocation(campaigns, historicalMetrics, totalBudget);\nconst recommendations = generateRecommendations(optimizedAllocations);\n\n// Sort by priority\nconst priorityOrder = { 'critical': 0, 'high': 1, 'medium': 2, 'low': 3 };\nrecommendations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);\n\n// Calculate overall impact\nconst totalExpectedRevenue = recommendations.reduce((sum, r) => sum + r.expected_additional_revenue, 0);\nconst avgROIImprovement = recommendations.reduce((sum, r) => sum + r.expected_roi_improvement, 0) / recommendations.length;\n\nreturn [{\n  json: {\n    optimization_summary: {\n      total_campaigns: campaigns.length,\n      total_budget: Math.round(totalBudget * 100) / 100,\n      recommendations_count: recommendations.length,\n      total_expected_additional_revenue: Math.round(totalExpectedRevenue * 100) / 100,\n      avg_roi_improvement: Math.round(avgROIImprovement * 100) / 100,\n      high_priority_actions: recommendations.filter(r => r.priority === 'high' || r.priority === 'critical').length,\n      generated_at: new Date().toISOString()\n    },\n    recommendations: recommendations\n  }\n}];"
      },
      "id": "optimize-budget",
      "name": "Optimize Budget Allocation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 400]
    },
    {
      "parameters": {
        "jsCode": "// Prepare recommendations for database insertion\nconst result = $input.first().json;\nconst records = [];\n\nresult.recommendations.forEach(rec => {\n  records.push({\n    json: {\n      campaign_id: rec.campaign_id,\n      organization_id: null, // Will be fetched from campaign\n      recommendation_type: 'budget_reallocation',\n      priority: rec.priority,\n      title: `${rec.change_percentage > 0 ? 'Increase' : rec.change_percentage < 0 ? 'Decrease' : 'Maintain'} Budget for ${rec.campaign_name}`,\n      description: rec.reasoning,\n      reasoning: rec.reasoning,\n      expected_impact: JSON.stringify({\n        metric: 'revenue',\n        current: rec.current_spend * rec.current_roi,\n        projected: (rec.recommended_budget * rec.predicted_roi),\n        improvement_pct: rec.expected_roi_improvement > 0 ? (rec.expected_roi_improvement / rec.current_roi * 100).toFixed(1) : 0\n      }),\n      confidence_score: rec.confidence,\n      implementation_steps: JSON.stringify([\n        `Update campaign budget from $${rec.current_budget} to $${rec.recommended_budget}`,\n        'Monitor performance for first 3 days',\n        rec.change_percentage > 0 ? 'Scale gradually if performance maintains' : 'Review campaign targeting and creative'\n      ]),\n      status: 'pending',\n      metadata: JSON.stringify({\n        budget_change: rec.budget_change,\n        change_percentage: rec.change_percentage,\n        predicted_roi: rec.predicted_roi,\n        scalability_score: rec.scalability_score\n      }),\n      created_at: new Date().toISOString(),\n      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // Expires in 7 days\n    }\n  });\n});\n\nreturn records;"
      },
      "id": "format-recommendations",
      "name": "Format for Database",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/campaign_recommendations",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "apikey", "value": "={{ $env.SUPABASE_SERVICE_KEY }}"},
            {"name": "Authorization", "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"},
            {"name": "Content-Type", "value": "application/json"}
          ]
        },
        "sendBody": true,
        "contentType": "application/json",
        "body": "={{ JSON.stringify($json) }}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 50
            }
          }
        }
      },
      "id": "save-recommendations",
      "name": "Save Recommendations",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/workflow_executions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "apikey", "value": "={{ $env.SUPABASE_SERVICE_KEY }}"},
            {"name": "Authorization", "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"},
            {"name": "Content-Type", "value": "application/json"}
          ]
        },
        "sendBody": true,
        "contentType": "application/json",
        "body": "={{ JSON.stringify({\n  workflow_name: 'campaign-budget-optimizer-v1',\n  execution_id: $execution.id,\n  trigger_type: 'schedule',\n  status: 'success',\n  items_processed: $('Optimize Budget Allocation').item.json.optimization_summary.total_campaigns,\n  output_data: $('Optimize Budget Allocation').item.json.optimization_summary,\n  completed_at: new Date().toISOString()\n}) }}"
      },
      "id": "log-execution",
      "name": "Log Execution",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1250, 400]
    }
  ],
  "connections": {
    "Daily at 6 AM": {
      "main": [
        [
          {"node": "Fetch Active Campaigns", "type": "main", "index": 0},
          {"node": "Fetch 30-Day History", "type": "main", "index": 0}
        ]
      ]
    },
    "Fetch Active Campaigns": {
      "main": [[{"node": "Optimize Budget Allocation", "type": "main", "index": 0}]]
    },
    "Fetch 30-Day History": {
      "main": [[{"node": "Optimize Budget Allocation", "type": "main", "index": 0}]]
    },
    "Optimize Budget Allocation": {
      "main": [[{"node": "Format for Database", "type": "main", "index": 0}]]
    },
    "Format for Database": {
      "main": [[{"node": "Save Recommendations", "type": "main", "index": 0}]]
    },
    "Save Recommendations": {
      "main": [[{"node": "Log Execution", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}