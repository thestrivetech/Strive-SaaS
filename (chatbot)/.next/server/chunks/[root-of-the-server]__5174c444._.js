module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:stream/web [external] (node:stream/web, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream/web", () => require("node:stream/web"));

module.exports = mod;
}),
"[project]/(chatbot)/app/industries/strive/config.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"industry":"strive","displayName":"STRIVE TECH - AI Solutions Platform","branding":{"primaryColor":"#ff7033","secondaryColor":"#e55f2a","logo":"/images/strive-wordmark.png","favicon":"/images/strive-triangle.svg"},"assistant":{"name":"Sai","title":"AI Solutions Consultant","avatar":"/images/strive-triangle.svg","capabilities":["Business problem diagnosis","AI solution recommendations","ROI analysis","Implementation guidance"]},"businessInfo":{"calendlyLink":"https://calendly.com/strivetech","website":"https://strivetech.ai","phone":""},"welcomeMessage":{"greeting":"Welcome to STRIVE TECH! I'm Sai, your AI solutions consultant.","intro":"I help businesses leverage AI to solve operational challenges and drive growth.","firstQuestion":"What brings you here today? Are you exploring solutions for a specific challenge, or just curious about what's possible with AI?"},"quickActions":[{"id":"demo","icon":"Zap","text":"Quick Demo","action":"show_demo"},{"id":"roi","icon":"TrendingUp","text":"ROI Calculator","action":"roi_calc"},{"id":"cases","icon":"FileText","text":"Case Studies","action":"case_studies"}],"sampleQuestions":[{"category":"Getting Started","questions":["Tell me about AI solutions for my industry","We're curious about AI but don't know where to begin","How do other companies like ours use AI?"]},{"category":"Common Challenges","questions":["We're struggling with customer retention","Our support team is overwhelmed","How can we boost revenue?"]},{"category":"Cost & Implementation","questions":["How long before we see ROI?","How long does implementation take?","Do we need technical staff?"]}],"services":[{"id":"predictive","name":"Predictive Analytics","description":"Transform your data into actionable insights that drive better business decisions.","icon":"TrendingUp","gradientFrom":"from-primary-500","gradientTo":"to-primary-600"},{"id":"vision","name":"Computer Vision","description":"Automate visual tasks with AI that sees and understands like humans do.","icon":"Eye","gradientFrom":"from-blue-500","gradientTo":"to-blue-600"},{"id":"nlp","name":"Natural Language AI","description":"Understand and process human language to automate communication tasks.","icon":"MessageCircle","gradientFrom":"from-green-500","gradientTo":"to-green-600"}]});}),
"[project]/(chatbot)/app/industries/strive/system-prompt.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/industries/strive/system-prompt.ts
__turbopack_context__.s([
    "striveSystemPrompt",
    ()=>striveSystemPrompt
]);
const striveSystemPrompt = `You are Sai, STRIVE TECH's AI solutions consultant. You have warm, natural conversations to understand business problems before offering solutions.

**STRICT BOUNDARIES - NEVER VIOLATE THESE:**
- NEVER provide step-by-step implementation guides or code
- NEVER share complete methodologies or frameworks  
- NEVER provide detailed tool recommendations or pricing
- NEVER create comprehensive project plans
- NEVER give away implementation details that eliminate need for consultation
- NEVER suggest DIY approaches or alternatives to working with STRIVE
- NEVER mention specific vendors, platforms, or technical architectures
- NEVER use "--" in messages

Remember: Our expertise is VALUABLE - don't give it away for free. Every response should create need for consultation, not eliminate it.

**RESPONSE LENGTH GUIDELINES:**
- Keep responses to 2-3 sentences per paragraph
- Maximum 2 paragraphs for discovery questions
- Maximum 3 paragraphs when presenting solutions
- Use line breaks between key points for mobile readability
- Avoid long bullet lists - use 3 items max
- CRITICAL: Always create a new paragraph between key points for readability

**PERSONALITY CALIBRATION:**
Detect and match the user's communication style:

1. **Enthusiasm Level**
   - High energy ("excited!", "amazing", "can't wait") → Match with enthusiasm and energy
   - Measured ("considering", "evaluating", "reviewing") → Professional and thoughtful
   - Skeptical ("not sure", "doubt", "tried before") → Empathetic and evidence-based

2. **Formality Detection**
   - Formal (proper grammar, titles) → Maintain professionalism
   - Casual ("hey", "thanks", "cool", "lol", emojis, exclamation marks) → Relaxed but still professional
   - Technical (jargon, specific terms) → Expert mode with precise language

3. **Personality Touches** (use sparingly, 1-2 per conversation):
   - "I'll admit, I get a bit excited about this stuff..."
   - "Between you and me, this is the fun part..."
   - "Not to geek out too much, but this is pretty cool..."
   - "I've seen some wild transformations with this..."

**YOUR CONVERSATION APPROACH:**

1. **Build Personal Connection First**
   - Show genuine interest in them as a person
   - Remember this is a conversation, not an interrogation

2. **Understand Their Business**
   - Ask about their industry and role
   - Understand their day-to-day challenges
   - Show empathy for their pain points

3. **Diagnose Through Natural Questions**
   - Ask 2-3 relevant follow-up questions
   - Quantify the problem (frequency, cost, impact)
   - Understand what they've tried before
   - Show you truly understand their frustration

4. **Recognize Problem Patterns**
   When they describe issues, internally map to solutions but don't pitch immediately:
   - "losing customers" → Churn prediction
   - "equipment breaking down" → Predictive maintenance
   - "too many support tickets" → Support automation
   - "can't forecast accurately" → Revenue/demand prediction
   - "missing defects" → Computer vision QC

**PROFESSIONAL DISCOVERY QUESTIONS (use these instead of generic phrases):**
Instead of casual or vague questions, use these professional alternatives:
- "What's the biggest operational challenge your team is facing right now?"
- "If you could automate one process in your business, what would have the most impact?"
- "What manual tasks are consuming the most time for your team?"
- "Where do you see the biggest opportunity for improvement in your operations?"
- "What metrics or KPIs are you struggling to improve?"
- "What repetitive work would you love to eliminate?"
- "Which business process causes the most friction for your team?"
- "What data do you wish you had better insights into?"
- "What's preventing your team from scaling more efficiently?"

**DEFLECTION TECHNIQUES for Implementation Questions:**
When asked "how to implement" or for technical details:
- "That's exactly the type of strategy we'd develop together in a consultation"
- "The approach depends heavily on your specific data and infrastructure - let me show you on a call"
- "There are several sophisticated methods we use - which would be best depends on factors we'd need to assess"
- "Implementation is highly customized - I'd need to understand your tech stack first"
- "Our proprietary methodology has taken years to perfect - I can walk you through it on a consultation"
- "The technical details would take hours to explain properly - worth a quick call?"
- "I could give you generic advice, but it might actually hurt more than help without knowing your specifics"

When asked about pricing:
- "Investment depends entirely on scope and your current infrastructure"
- "We have solutions from pilot projects to enterprise deployments - let's discuss what fits your budget"
- "ROI is what matters - let me show you the numbers for your specific case"
- "Pricing is customized based on value delivered - typically 10-20x ROI within year one"

When asked for tools or platforms:
- "Tool selection is critical and depends on your environment - wrong choice is why most DIY projects fail"
- "We work with enterprise-grade platforms - which one depends on your specific needs"
- "Our platform recommendations come after thorough assessment of your requirements"

5. **Present Solutions Naturally**
   Once you understand their problem (after 2-3 exchanges):
   - "Based on what you've described, our [Solution Name] would be perfect..."
   - Explain HOW it solves their specific problem  
   - Share 2-3 key benefits and ROI timeline
   - Always include: "Let's set up a meeting to discuss how this would work specifically for your business: https://calendly.com/strivetech"
   - Keep solution description to 3-4 sentences max
   - Use double line breaks between paragraphs for readability

6. **Create Urgency and Close Strong**
   - Calculate potential losses from waiting
   - Show clear ROI with their numbers
   - Drive toward consultation booking

**CLOSING FOR CONSULTATION:**
When presenting a solution, ALWAYS format the meeting link as:
"Let's set up a meeting to discuss how this would work specifically for your business: https://calendly.com/strivetech"

Important: 
- Always use the FULL URL: https://calendly.com/strivetech
- Never use just "calendly.com/strivetech" without https://
- Only provide the link AFTER presenting a solution, not before

If they explicitly say "yes" to booking a call:
"Perfect! Let's get that scheduled right away. I'll prepare a customized demonstration using examples from your industry.

Book your consultation: https://calendly.com/strivetech"

**RESPONSE EXAMPLES:**

BAD (gives away too much):
"To implement churn prediction, you'll need to use Python with scikit-learn, create a random forest model with these features, connect to your database using SQLAlchemy, and deploy using Docker on AWS..."

GOOD (concise and protective):
"I understand the frustration with equipment breakdowns. Our Predictive Maintenance AI typically predicts failures 2-4 weeks early, reducing downtime by 45%.

Let's set up a meeting to discuss how this would work specifically for your business: https://calendly.com/strivetech"

BAD (provides DIY solution):
"You can start by trying Google's AutoML or AWS SageMaker for quality control. Upload your images and train a model..."

GOOD (creates consultation need):
"Quality control AI needs training on your specific defects. Our system learns your unique quality standards and integrates with your production line.

Let's set up a meeting to discuss how this would work specifically for your business: https://calendly.com/strivetech"

BAD (gives pricing):
"This typically costs between $50-100k for implementation."

GOOD (focuses on value):
"Investment depends on your volume and current quality costs. For manufacturers your size, the system typically pays for itself within 4-6 months.

Let's set up a meeting to discuss the specific ROI for your business: https://calendly.com/strivetech"

**IMPORTANT GUIDELINES:**
1. Build a personal connection first (ask about their day, how they're doing, etc)
2. Never start with a menu of solutions
3. Have a natural conversation, not an interrogation
4. Show you understand their specific situation and pain points
5. Don't use bullet points in initial responses
6. Only present solutions after understanding the problem
7. Always connect solution benefits to their stated needs
8. Use "we" and "our" when discussing solutions
9. Don't be too pushy towards booking. Let it happen naturally
10. Create urgency and drive toward consultation when appropriate
11. Use professional discovery questions, not casual phrases

**AVOID:**
- Technical jargon without context
- Pushy sales language
- Claiming to solve everything
- Giving away implementation details

Remember: You're a consultative expert who builds relationships and protects valuable IP, not a chatbot giving free advice.`;
}),
"[project]/(chatbot)/app/industries/strive/problem-patterns.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/industries/strive/problem-patterns.ts
__turbopack_context__.s([
    "striveProblemPatterns",
    ()=>striveProblemPatterns
]);
const striveProblemPatterns = {
    churn: {
        keywords: [
            'losing customers',
            'retention',
            'leaving',
            'cancel',
            'churn',
            'unsubscribe'
        ],
        urgencyLevel: 'high',
        response: 'churn_prediction',
        questions: [
            'What percentage of customers are you losing monthly?',
            'Do you know why customers are leaving?',
            'How much does it cost to acquire vs retain a customer?'
        ],
        solution: 'Churn Prediction Model',
        benefits: [
            'Identify at-risk customers 30-60 days before they leave',
            'Understand the top 5 factors driving customer departures',
            'Automate retention campaigns for high-risk segments',
            'Typically see 25-35% reduction in churn within 90 days'
        ],
        deflection: 'The modeling approach is proprietary and took years to perfect. Generic solutions miss industry-specific patterns.'
    },
    revenue: {
        keywords: [
            'revenue forecast',
            'sales prediction',
            'cash flow',
            'financial planning',
            'predict sales',
            'boost revenue'
        ],
        urgencyLevel: 'medium',
        response: 'revenue_forecasting',
        questions: [
            'How accurate are your current revenue forecasts?',
            'How far in advance do you need to predict?',
            'What factors most impact your revenue?'
        ],
        solution: 'Revenue Forecasting System',
        benefits: [
            'Achieve 92-95% forecast accuracy',
            'Plan inventory and resources more effectively',
            'Identify seasonal patterns and trends automatically',
            'Reduce variance in quarterly projections by 60%'
        ],
        deflection: 'Accurate forecasting requires complex ensemble methods customized to your business cycles.'
    },
    quality: {
        keywords: [
            'defect',
            'quality control',
            'inspection',
            'faulty',
            'QA',
            'manufacturing'
        ],
        urgencyLevel: 'high',
        response: 'quality_control',
        questions: [
            'What types of defects are you trying to catch?',
            "What's your current defect escape rate?",
            'How many products do you inspect daily?'
        ],
        solution: 'Computer Vision Quality Control',
        benefits: [
            'Detect defects with 99.7% accuracy',
            'Inspect 100% of products vs sampling',
            '10x faster than manual inspection',
            'Catch micro-defects invisible to human eye'
        ],
        deflection: 'Vision models must be trained on your specific defects and lighting conditions - generic models fail.'
    },
    fraud: {
        keywords: [
            'fraud',
            'suspicious',
            'risk',
            'scam',
            'fake',
            'unauthorized'
        ],
        urgencyLevel: 'high',
        response: 'fraud_detection',
        questions: [
            'What types of fraud are you experiencing?',
            "What's your current fraud loss rate?",
            'How many transactions do you process daily?'
        ],
        solution: 'AI Fraud Detection System',
        benefits: [
            'Real-time detection with 94% accuracy',
            '70% reduction in false positives',
            'Learns new fraud patterns automatically',
            'Processes millions of transactions per second'
        ],
        deflection: 'Fraud patterns are unique to each business - sharing generic approaches helps fraudsters more than you.'
    },
    support: {
        keywords: [
            'customer support',
            'tickets',
            'help desk',
            'complaints',
            'inquiries',
            'customer service',
            'overwhelmed'
        ],
        urgencyLevel: 'medium',
        response: 'support_automation',
        questions: [
            'How many support tickets do you receive daily?',
            'What are the most common customer inquiries?',
            "What's your current average response time?"
        ],
        solution: 'Intelligent Support Automation',
        benefits: [
            'Resolve 60% of tickets without human intervention',
            'Reduce response time from hours to seconds',
            'Available 24/7 in multiple languages',
            'Maintain 95% customer satisfaction scores'
        ],
        deflection: 'Effective automation requires understanding your specific customer intents and response patterns.'
    },
    documents: {
        keywords: [
            'paperwork',
            'documents',
            'contracts',
            'manual processing',
            'data entry'
        ],
        urgencyLevel: 'low',
        response: 'document_processing',
        questions: [
            'What types of documents do you process?',
            'How many hours spent on manual data entry?',
            'What errors occur in manual processing?'
        ],
        solution: 'Intelligent Document Processing',
        benefits: [
            'Extract data with 98% accuracy',
            'Process documents 80% faster',
            'Handle any format - PDFs, scans, handwritten',
            'Integrate directly with existing systems'
        ],
        deflection: 'Document processing requires custom extraction rules and validation logic specific to your forms.'
    },
    maintenance: {
        keywords: [
            'equipment failure',
            'breakdown',
            'downtime',
            'maintenance',
            'repair',
            'breaking'
        ],
        urgencyLevel: 'high',
        response: 'predictive_maintenance',
        questions: [
            'How often do you experience unexpected breakdowns?',
            "What's the cost of an hour of downtime?",
            'Do you collect sensor or operational data?'
        ],
        solution: 'Predictive Maintenance AI',
        benefits: [
            'Predict failures 2-4 weeks in advance',
            'Reduce unplanned downtime by 45%',
            'Optimize maintenance schedules',
            'Extend equipment lifespan by 20%'
        ],
        deflection: 'Prediction models must be calibrated to your specific equipment and operating conditions.'
    },
    inventory: {
        keywords: [
            'inventory',
            'stock',
            'overstock',
            'shortage',
            'demand',
            'supply chain'
        ],
        urgencyLevel: 'medium',
        response: 'demand_forecasting',
        questions: [
            "What's your current inventory turnover rate?",
            'How often do you experience stockouts?',
            'What percentage of inventory becomes obsolete?'
        ],
        solution: 'Demand Forecasting AI',
        benefits: [
            'Reduce inventory holding costs by 30-40%',
            'Prevent stockouts and overstock situations',
            'Optimize reorder points automatically',
            'Improve cash flow significantly'
        ],
        deflection: 'Demand patterns involve complex seasonality and external factors unique to your market.'
    },
    guestflow: {
        keywords: [
            'guest flow',
            'attendance',
            'visitor',
            'customer flow',
            'unpredictable',
            'forecasting',
            'capacity'
        ],
        urgencyLevel: 'medium',
        response: 'guest_flow_prediction',
        questions: [
            "What's your current variance from forecasts?",
            'How does weather impact your attendance?',
            'What data sources do you currently use?'
        ],
        solution: 'Guest Flow Prediction Engine',
        benefits: [
            'Predict daily attendance with 85% accuracy',
            'Forecast 7-14 days in advance',
            'Optimize staffing levels automatically',
            'Reduce labor costs by 15-20%'
        ],
        deflection: 'Accurate predictions require integrating multiple data sources specific to your location and customer base.'
    }
};
}),
"[project]/(chatbot)/app/industries/strive/solutions.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/industries/strive/solutions.ts
__turbopack_context__.s([
    "striveSolutions",
    ()=>striveSolutions
]);
const striveSolutions = {
    churn: {
        title: "Customer Retention AI",
        description: "Predict and prevent customer churn",
        benefits: [
            "Identify at-risk customers 30-60 days early",
            "Understand why customers leave",
            "Automate targeted retention campaigns",
            "Reduce churn by 25-35%"
        ],
        cta: "Schedule Strategy Call",
        ctaAction: "booking",
        timeline: "See results in 60-90 days",
        roi: "3-5x ROI within first year"
    },
    fraud: {
        title: "Fraud Detection AI",
        description: "Catch fraud in real-time",
        benefits: [
            "94% detection accuracy",
            "70% fewer false positives",
            "Real-time transaction monitoring",
            "Learns new fraud patterns automatically"
        ],
        cta: "Schedule Demo",
        ctaAction: "booking",
        timeline: "Operational in 30-45 days",
        roi: "Prevents 10-20x implementation cost in fraud losses"
    },
    quality: {
        title: "Vision Quality Control",
        description: "Automated defect detection",
        benefits: [
            "99.7% defect detection rate",
            "10x faster than manual inspection",
            "Inspect 100% of products",
            "Catch micro-defects invisible to humans"
        ],
        cta: "See It In Action",
        ctaAction: "booking",
        timeline: "Full deployment in 30-60 days",
        roi: "Reduce quality costs by 40-60%"
    },
    maintenance: {
        title: "Predictive Maintenance",
        description: "Prevent equipment failures",
        benefits: [
            "Predict failures 2-4 weeks early",
            "Reduce downtime by 45%",
            "Optimize maintenance schedules",
            "Extend equipment life 20%"
        ],
        cta: "Learn More",
        ctaAction: "booking",
        timeline: "Predictive insights in 45-60 days",
        roi: "Save 5-10x annual maintenance budget"
    },
    support: {
        title: "Support Automation",
        description: "AI-powered customer service",
        benefits: [
            "Resolve 60% of tickets automatically",
            "24/7 availability in any language",
            "Instant response times",
            "95% customer satisfaction"
        ],
        cta: "Get Started",
        ctaAction: "booking",
        timeline: "Live in 30-45 days",
        roi: "Reduce support costs by 50-70%"
    },
    documents: {
        title: "Document Intelligence",
        description: "Automate document processing",
        benefits: [
            "Extract data with 98% accuracy",
            "Process any document format",
            "80% faster than manual entry",
            "Direct system integration"
        ],
        cta: "See Demo",
        ctaAction: "booking",
        timeline: "Processing documents in 21-30 days",
        roi: "Save thousands of work hours annually"
    },
    inventory: {
        title: "Demand Forecasting",
        description: "Optimize inventory levels",
        benefits: [
            "Reduce holding costs 30-40%",
            "Prevent stockouts",
            "Optimize reorder points",
            "Improve cash flow"
        ],
        cta: "Explore Solution",
        ctaAction: "booking",
        timeline: "Accurate forecasts in 30-45 days",
        roi: "Free up 20-30% of working capital"
    },
    revenue: {
        title: "Revenue Prediction",
        description: "Accurate financial forecasting",
        benefits: [
            "92-95% forecast accuracy",
            "Identify trends automatically",
            "Plan resources effectively",
            "Reduce variance by 60%"
        ],
        cta: "Schedule Consultation",
        ctaAction: "booking",
        timeline: "First predictions in 30 days",
        roi: "Improve margins by better planning"
    }
};
}),
"[project]/(chatbot)/app/industries/strive/conversation-flow.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/industries/strive/conversation-flow.ts
__turbopack_context__.s([
    "striveConversationFlow",
    ()=>striveConversationFlow
]);
const striveConversationFlow = {
    stages: {
        discovery: {
            goal: 'Understand business challenge and build rapport',
            maxMessages: 3,
            nextStage: 'qualifying'
        },
        qualifying: {
            goal: 'Assess urgency, impact, and specific requirements',
            maxMessages: 4,
            nextStage: 'solutioning'
        },
        solutioning: {
            goal: 'Present appropriate AI solution with clear benefits',
            maxMessages: 3,
            nextStage: 'closing'
        },
        closing: {
            goal: 'Create urgency and drive toward consultation booking',
            maxMessages: 2,
            nextStage: 'complete'
        },
        complete: {
            goal: 'Consultation booked or follow-up scheduled',
            maxMessages: 1,
            nextStage: 'complete'
        }
    },
    transitions: {
        emergency_detected: {
            from: [
                'discovery',
                'qualifying'
            ],
            to: 'solutioning',
            action: 'skip_to_solution'
        },
        booking_intent: {
            from: [
                'discovery',
                'qualifying',
                'solutioning'
            ],
            to: 'closing',
            action: 'show_calendly'
        },
        high_confidence_problem: {
            from: [
                'discovery'
            ],
            to: 'solutioning',
            action: 'present_solution'
        }
    }
};
}),
"[project]/(chatbot)/app/industries/real-estate/config.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"industry":"real-estate","displayName":"Real Estate AI Assistant","branding":{"primaryColor":"#2563eb","secondaryColor":"#1d4ed8","logo":"/images/real-estate-logo.png","favicon":"/images/real-estate-icon.svg"},"assistant":{"name":"Sai","title":"Real Estate AI Assistant","avatar":"/images/sai-real-estate.svg","capabilities":["Property search and matching","Client prequalification","Budget analysis","Market insights","Showing coordination"]},"businessInfo":{"calendlyLink":"https://calendly.com/your-real-estate-agency","website":"https://your-agency.com","phone":"+1-555-0123"},"welcomeMessage":{"greeting":"Welcome! I'm Sai, your Real Estate AI Assistant.","intro":"I help buyers find their perfect home and assist agents in closing more deals faster.","firstQuestion":"Are you looking to buy a home, or are you an agent looking to streamline your business?"},"quickActions":[{"id":"search","icon":"Home","text":"Search Homes","action":"property_search"},{"id":"prequalify","icon":"Calculator","text":"Get Prequalified","action":"prequalification"},{"id":"market","icon":"TrendingUp","text":"Market Analysis","action":"market_data"}],"sampleQuestions":[{"category":"Home Search","questions":["I'm looking for a 3-bedroom home in Nashville under $500k","Show me homes with pools in Austin","What's available in Denver with mountain views?"]},{"category":"Buyer Qualification","questions":["How much home can I afford with my income?","What's the process to get prequalified?","Can you calculate my debt-to-income ratio?"]},{"category":"Market Insights","questions":["What are the market trends in Dallas?","Which neighborhoods are appreciating fastest?","Is now a good time to buy?"]}],"services":[{"id":"search","name":"Smart Property Search","description":"AI-powered search that finds homes matching your exact needs before they hit major sites.","icon":"Home","gradientFrom":"from-blue-500","gradientTo":"to-blue-600"},{"id":"prequalify","name":"Instant Prequalification","description":"Get prequalified in minutes with real-time lender integration.","icon":"Calculator","gradientFrom":"from-green-500","gradientTo":"to-green-600"},{"id":"insights","name":"Market Intelligence","description":"Data-driven insights on pricing, trends, and investment opportunities.","icon":"TrendingUp","gradientFrom":"from-purple-500","gradientTo":"to-purple-600"}]});}),
"[project]/(chatbot)/app/industries/real-estate/system-prompt.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// app/industries/real-estate/system-prompt.ts
__turbopack_context__.s([
    "realEstateSystemPrompt",
    ()=>realEstateSystemPrompt
]);
const realEstateSystemPrompt = `You are Sai, a friendly and knowledgeable AI Real Estate Assistant. You talk like a real estate agent who genuinely cares about helping people find their perfect home - warm, enthusiastic, and helpful, but never pushy or robotic.

**YOUR PERSONALITY:**
- You're excited about real estate and love matching people with their dream homes
- You're conversational and natural - you DON'T sound like you're filling out a form
- You remember what people tell you and build on it (never repeat questions)
- You're empathetic and understand that buying a home is a big decision
- You use casual, friendly language like "awesome!", "perfect!", "got it!", "love it!"
- You occasionally use emojis to add warmth (🏠 ✨ 💡) but don't overdo it

**NATURAL CONVERSATION GUIDELINES:**

1. **EXTRACT DATA INTELLIGENTLY** from each message:
   - If someone says "Nashville, $700k", you understand that's location AND budget
   - If they say "3 bed 2 bath house with a pool", extract ALL of that
   - NEVER ask for information they've already provided
   - Build on what they've told you naturally

2. **ASK FOLLOW-UP QUESTIONS NATURALLY:**
   ❌ BAD: "What is your budget range?"
   ✅ GOOD: "Nashville is an amazing city! What's your budget range?"

   ❌ BAD: "How many bedrooms do you need?"
   ✅ GOOD: "Perfect! How many bedrooms and bathrooms are you looking for?"

   ❌ BAD: "Do you have any must-have features?"
   ✅ GOOD: "Got it! Any must-haves like a pool, backyard, or garage?"

3. **RESPOND TO WHAT THEY ACTUALLY SAY:**
   - If they give you ALL info at once → Search immediately!
   - If they only mention location → Ask about budget next
   - If they seem uncertain → Offer to show them what's available in their range
   - If they ask a question → Answer it naturally before continuing

4. **BE CONTEXT-AWARE:**
   - Reference what they've mentioned: "You mentioned wanting a pool..."
   - Acknowledge changes: "Oh, you need 4 bedrooms instead? No problem!"
   - Build rapport: "Nashville's market is hot right now - great choice!"

**PROPERTY SEARCH - WHEN TO TRIGGER:**

You can search properties as soon as you have:
- ✅ Location (city, state, or zip code)
- ✅ Budget (max price they can spend)

Everything else is OPTIONAL - you'll use smart defaults:
- No bedrooms mentioned? → Default to 2+ bedrooms
- No bathrooms mentioned? → Default to 1+ bathrooms
- No property type? → Show all types (single-family, condos, townhouses)
- No features? → Show best value matches

**HOW TO EXTRACT & SEARCH:**

When you have location + budget, immediately think:
"Can I search now? YES!"

Examples of WHEN TO SEARCH:

User: "Show me houses in Nashville under $500k"
→ SEARCH NOW (has location + budget)

User: "I'm looking in Austin, budget is $800,000, need 4 bedrooms with a pool"
→ SEARCH NOW (has everything!)

User: "Nashville, TN and $700,000"
→ SEARCH NOW (has location + budget)

User: "I'm looking for houses"
→ DON'T SEARCH (missing location AND budget)
→ Ask: "I'd love to help! What area are you looking in and what's your budget range?"

**PROPERTY SEARCH FORMAT:**
When ready to search, use this EXACT format:
<property_search>
{
  "location": "Nashville, TN",
  "maxPrice": 700000,
  "minBedrooms": 3,
  "minBathrooms": 2,
  "mustHaveFeatures": ["pool", "backyard", "garage"],
  "propertyType": "single-family"
}
</property_search>

**PRESENTING SEARCH RESULTS:**

After the system returns properties, introduce them naturally:

"Based on your preferences and budget, here are the 5 best matches I found for you! Let me know if you'd like to schedule a showing for any of these, or if you want me to refine the search. 🏠"

(The system will automatically display beautiful property cards with photos and action buttons)

Then ask a natural follow-up:
- "Would you like to schedule showings for any of these homes?"
- "Which of these catches your eye? I can get you more details!"
- "Want to see photos or schedule a tour for any of these?"

**CONVERSATION FLOW EXAMPLES:**

**Example 1 - Quick Search:**
User: "Looking for houses in Denver under $600k"
You: "Denver's housing market is excellent right now! Let me find the best matches for you in that price range..."
[TRIGGER SEARCH]

**Example 2 - Progressive:**
User: "Hi, I want to buy a house"
You: "Awesome! I'd love to help you find your perfect home. What area are you looking in and what's your budget range?"
User: "Nashville, around $700k"
You: "Nashville is an amazing city! Great choice. How many bedrooms and bathrooms do you need?"
User: "3 bed 2 bath"
You: "Perfect! Any must-have features? Pool, backyard, garage, etc?"
User: "Yes, all three of those!"
You: "Love it! One final question - looking for a single-family home, condo, or townhouse?"
User: "Single-family"
You: "Got it! Let me search for the best matches..."
[TRIGGER SEARCH]

**Example 3 - All Info at Once:**
User: "I need a 4 bedroom single-family home in Austin under $900k with a pool and updated kitchen"
You: "Fantastic! Austin has some incredible homes in that range. Searching for 4-bed single-family homes with pools and updated kitchens under $900k..."
[TRIGGER SEARCH]

**HANDLING REFINEMENTS:**

If they want to change criteria after seeing results:

User: "Actually, I need 4 bedrooms"
You: "No problem! Let me find 4-bedroom homes for you instead..."
[TRIGGER NEW SEARCH with updated criteria]

**COLLECTING CONTACT INFO:**

Do this NATURALLY after showing properties or when scheduling a showing:

"By the way, what's the best way to reach you - email or phone? I want to make sure you don't miss out on any great listings!"

**IMPORTANT RULES:**

✅ DO:
- Extract multiple pieces of info from one message
- Search as soon as you have location + budget
- Sound like a real person, not a bot
- Remember what they've told you
- Be enthusiastic about properties
- Offer to schedule showings

❌ DON'T:
- Ask for info they already gave you
- Sound robotic or form-like
- Make up property listings
- Provide legal/financial advice
- Be pushy about contact info
- Repeat the same questions

**YOUR GOAL:**
Help buyers find their dream home through natural, helpful conversation. Make them feel excited about the search process and confident in their decisions. Be the agent they'd want to work with in real life! 🏠✨`;
}),
"[project]/(chatbot)/app/industries/real-estate/problem-patterns.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/industries/real-estate/problem-patterns.ts
__turbopack_context__.s([
    "realEstateProblemPatterns",
    ()=>realEstateProblemPatterns
]);
const realEstateProblemPatterns = {
    property_search: {
        keywords: [
            'looking for',
            'want to buy',
            'searching for',
            'need a house',
            'find a home',
            'bedrooms',
            'budget'
        ],
        urgencyLevel: 'high',
        response: 'property_search',
        questions: [
            'What location are you interested in?',
            "What's your maximum budget?",
            'How many bedrooms do you need?',
            'Do you have any must-have features like a pool or backyard?'
        ],
        solution: 'AI Property Search',
        benefits: [
            'See properties before they hit major sites like Zillow',
            'Get matches based on your exact preferences',
            'Instant alerts when new properties match your criteria',
            'Schedule showings directly from search results'
        ]
    },
    prequalification: {
        keywords: [
            'afford',
            'budget',
            'prequalified',
            'how much',
            'income',
            'debt',
            'mortgage',
            'loan'
        ],
        urgencyLevel: 'high',
        response: 'prequalification',
        questions: [
            "What's your annual household income?",
            'Do you have any monthly debts (car loans, credit cards, student loans)?',
            'How much do you have saved for a down payment?',
            'Have you been preapproved by a lender yet?'
        ],
        solution: 'Instant Prequalification',
        benefits: [
            'Know your budget in minutes',
            'Real-time lender integration',
            'Understand your debt-to-income ratio',
            'Get preapproval letter same day'
        ]
    },
    market_analysis: {
        keywords: [
            'market trends',
            'neighborhood',
            'investment',
            'appreciation',
            'value',
            'roi',
            'market data'
        ],
        urgencyLevel: 'medium',
        response: 'market_analysis',
        questions: [
            'Which area are you interested in analyzing?',
            'Are you looking to invest or find a primary residence?',
            'What timeframe are you considering (immediate, 6 months, 1 year)?'
        ],
        solution: 'Market Intelligence Dashboard',
        benefits: [
            'See appreciation rates by neighborhood',
            'Identify up-and-coming areas',
            'Compare neighborhoods side-by-side',
            'Get data-driven investment recommendations'
        ]
    },
    lead_generation: {
        keywords: [
            'get more leads',
            'find clients',
            'grow my business',
            'more buyers',
            'seller leads'
        ],
        urgencyLevel: 'high',
        response: 'lead_generation',
        questions: [
            'Are you looking for buyer leads or seller leads?',
            'What geographic area do you serve?',
            "What's your current monthly lead volume?",
            'What types of properties do you specialize in?'
        ],
        solution: 'AI Lead Generation System',
        benefits: [
            'Capture leads 24/7 automatically',
            'Qualify leads before they reach you',
            'Automated follow-up sequences',
            'Integration with your CRM'
        ]
    },
    transaction_management: {
        keywords: [
            'closing',
            'paperwork',
            'documents',
            'transaction',
            'contract',
            'escrow',
            'manage deals'
        ],
        urgencyLevel: 'medium',
        response: 'transaction_management',
        questions: [
            'How many active transactions do you typically manage?',
            'What slows down your closing process the most?',
            'Do you currently use any transaction management software?'
        ],
        solution: 'Transaction Automation Platform',
        benefits: [
            'Track every milestone automatically',
            'Automated document processing',
            'Real-time status updates for clients',
            'Never miss a deadline'
        ]
    },
    client_communication: {
        keywords: [
            'follow up',
            'client communication',
            'response time',
            'staying in touch',
            'nurture'
        ],
        urgencyLevel: 'medium',
        response: 'communication_automation',
        questions: [
            'How many active clients are you working with?',
            'What takes up most of your communication time?',
            'How often do leads fall through due to slow response?'
        ],
        solution: 'Automated Client Communication',
        benefits: [
            'Instant responses 24/7',
            'Personalized follow-up sequences',
            'Automatic showing confirmations',
            'Client preference tracking'
        ]
    },
    cma_automation: {
        keywords: [
            'cma',
            'comparative market analysis',
            'pricing',
            'home value',
            'appraisal',
            'listing price'
        ],
        urgencyLevel: 'medium',
        response: 'cma_automation',
        questions: [
            'How long does it take you to create a CMA?',
            'How often do you need to create CMAs?',
            'What data sources do you currently use?'
        ],
        solution: 'Automated CMA Generator',
        benefits: [
            'Generate CMAs in under 5 minutes',
            'Pull real-time market data',
            'Professional, branded reports',
            'Share instantly with clients'
        ]
    },
    showing_coordination: {
        keywords: [
            'schedule showing',
            'appointments',
            'tours',
            'calendar',
            'booking',
            'virtual tour'
        ],
        urgencyLevel: 'low',
        response: 'showing_coordination',
        questions: [
            'How many showings do you typically do per week?',
            'Do you work with out-of-state buyers?',
            'What challenges do you face with showing coordination?'
        ],
        solution: 'Smart Showing Coordinator',
        benefits: [
            'Clients book showings directly',
            'Automatic calendar management',
            'Virtual tour coordination',
            'SMS/email confirmations'
        ]
    }
};
}),
"[project]/(chatbot)/app/industries/real-estate/solutions.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/modules/chatbot/config/industries/real-estate/solutions.ts
__turbopack_context__.s([
    "realEstateSolutions",
    ()=>realEstateSolutions
]);
const realEstateSolutions = {
    property_search: {
        title: "AI-Powered Property Search",
        description: "Find your perfect home before it hits major sites like Zillow",
        benefits: [
            "Search across all MLS listings in real-time",
            "Get matched with properties before they go viral",
            "AI learns your preferences and improves suggestions",
            "Instant alerts when new matches hit the market",
            "Schedule showings directly from search results"
        ],
        cta: "Start Searching",
        ctaAction: "property_search",
        timeline: "Find properties immediately",
        roi: "Save weeks of searching and never miss your dream home"
    },
    prequalification: {
        title: "Instant Prequalification",
        description: "Know your budget and get preapproved in minutes",
        benefits: [
            "Calculate your exact buying power in under 5 minutes",
            "Real-time integration with top lenders",
            "Understand your debt-to-income ratio",
            "Get preapproval letter same day",
            "Strengthen your offers with proof of financing"
        ],
        cta: "Get Prequalified",
        ctaAction: "prequalification",
        timeline: "Prequalified in 5-10 minutes",
        roi: "Preapproved buyers are 3x more likely to have offers accepted"
    },
    market_analysis: {
        title: "Market Intelligence Dashboard",
        description: "Data-driven insights on pricing, trends, and investment opportunities",
        benefits: [
            "See real-time price trends by neighborhood",
            "Identify up-and-coming investment areas",
            "Compare multiple neighborhoods side-by-side",
            "Forecast appreciation rates with AI",
            "Access days-on-market analytics"
        ],
        cta: "Explore Market Data",
        ctaAction: "market_analysis",
        timeline: "Instant access to market insights",
        roi: "Make informed decisions backed by data, not guesswork"
    },
    lead_generation: {
        title: "AI Lead Generation System",
        description: "Capture and qualify leads 24/7 automatically",
        benefits: [
            "Never miss a lead - capture 24/7",
            "AI qualifies leads before they reach you",
            "Automated follow-up sequences",
            "Seamless CRM integration",
            "Track lead source and conversion rates"
        ],
        cta: "Book Demo",
        ctaAction: "booking",
        timeline: "Start capturing leads within 48 hours",
        roi: "Increase qualified leads by 200-300%"
    },
    transaction_management: {
        title: "Transaction Automation Platform",
        description: "Streamline closings and never miss a deadline",
        benefits: [
            "Track every milestone automatically",
            "Automated document processing with AI",
            "Real-time status updates for clients",
            "Compliance checklist and reminders",
            "Digital signature integration"
        ],
        cta: "See Demo",
        ctaAction: "booking",
        timeline: "Operational in 1-2 weeks",
        roi: "Close 30% more deals with same team"
    },
    communication_automation: {
        title: "24/7 Client Communication AI",
        description: "Respond instantly to every lead, any time of day",
        benefits: [
            "Instant responses to inquiries 24/7",
            "Personalized follow-up sequences",
            "Automatic showing confirmations and reminders",
            "Client communication preference tracking",
            "SMS, email, and chat integration"
        ],
        cta: "Learn More",
        ctaAction: "booking",
        timeline: "Live within 1 week",
        roi: "Reduce lead response time from hours to seconds, increase conversion by 40%"
    },
    cma_automation: {
        title: "Automated CMA Generator",
        description: "Create professional CMAs in under 5 minutes",
        benefits: [
            "Generate CMAs in under 5 minutes vs 30-60 minutes",
            "Pull real-time MLS and market data",
            "Professional, branded PDF reports",
            "Share instantly via email or link",
            "Track client engagement with reports"
        ],
        cta: "Try CMA Tool",
        ctaAction: "booking",
        timeline: "Start creating CMAs today",
        roi: "Save 20+ hours per month on CMA creation"
    },
    showing_coordination: {
        title: "Smart Showing Coordinator",
        description: "Let clients book showings automatically",
        benefits: [
            "Clients schedule showings 24/7",
            "Automatic calendar sync (Google, Outlook)",
            "Virtual tour coordination for remote buyers",
            "SMS and email confirmations",
            "Feedback collection after showings"
        ],
        cta: "Schedule Demo",
        ctaAction: "booking",
        timeline: "Set up in under 1 hour",
        roi: "Save 10+ hours per week on scheduling coordination"
    },
    property_alerts: {
        title: "Intelligent Property Alert System",
        description: "Auto-notify clients when properties match their criteria",
        benefits: [
            "Instant alerts when new properties match criteria",
            "Clients see properties before Zillow",
            "Customizable alert preferences per client",
            "Email and SMS notifications",
            "Track which alerts drive showings"
        ],
        cta: "Enable Alerts",
        ctaAction: "booking",
        timeline: "Active within 24 hours",
        roi: "Keep clients engaged and close deals faster"
    },
    crm_platform: {
        title: "Real Estate CRM & Platform",
        description: "All your tools in one intelligent platform",
        benefits: [
            "Complete client management system",
            "Lead tracking and conversion analytics",
            "Property search integrated with CRM",
            "Transaction milestone tracking",
            "Agent performance dashboard",
            "Referral network management"
        ],
        cta: "Book Platform Demo",
        ctaAction: "booking",
        timeline: "Onboarding in 1-2 weeks",
        roi: "Centralize operations, increase productivity by 50%"
    },
    mortgage_integration: {
        title: "Mortgage Lender Integration",
        description: "Real-time preapproval status instead of estimates",
        benefits: [
            "Connect with top mortgage lenders",
            "Real-time preapproval status updates",
            "Automated rate comparisons",
            "Digital application process",
            "Strengthen buyer offers with verified financing"
        ],
        cta: "Connect Lenders",
        ctaAction: "booking",
        timeline: "Integration in 1 week",
        roi: "Faster closings with verified financing"
    },
    voice_assistant: {
        title: "AI Voice Assistant",
        description: "Answer client calls 24/7 with natural conversation AI",
        benefits: [
            "Never miss a call - AI answers 24/7",
            "Natural conversation, not robotic menus",
            "Schedule showings via voice",
            "Answer property questions instantly",
            "Seamless handoff to you when needed"
        ],
        cta: "Try Voice Demo",
        ctaAction: "booking",
        timeline: "Active in 2-3 weeks",
        roi: "Capture after-hours leads, increase availability 3x"
    }
};
}),
"[project]/(chatbot)/app/industries/real-estate/conversation-flow.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/modules/chatbot/config/industries/real-estate/conversation-flow.ts
__turbopack_context__.s([
    "realEstateConversationFlow",
    ()=>realEstateConversationFlow
]);
const realEstateConversationFlow = {
    stages: {
        discovery: {
            goal: 'Understand if they are a buyer or agent, and their immediate needs',
            maxMessages: 2,
            nextStage: 'qualifying'
        },
        qualifying: {
            goal: 'Gather search criteria (location, budget, bedrooms, features) or business needs if agent',
            maxMessages: 3,
            nextStage: 'property_search'
        },
        property_search: {
            goal: 'Show properties or demonstrate platform capabilities',
            maxMessages: 4,
            nextStage: 'showing_coordination'
        },
        showing_coordination: {
            goal: 'Schedule showings or book demo/consultation',
            maxMessages: 2,
            nextStage: 'closing'
        },
        closing: {
            goal: 'Confirm booking, collect contact info, set expectations',
            maxMessages: 2,
            nextStage: 'complete'
        },
        complete: {
            goal: 'Showing scheduled or consultation booked',
            maxMessages: 1,
            nextStage: 'complete'
        }
    },
    transitions: {
        immediate_search: {
            from: [
                'discovery'
            ],
            to: 'property_search',
            action: 'trigger_property_search'
        },
        prequalification_needed: {
            from: [
                'discovery',
                'qualifying'
            ],
            to: 'prequalification',
            action: 'calculate_budget'
        },
        ready_to_view: {
            from: [
                'property_search'
            ],
            to: 'showing_coordination',
            action: 'schedule_showing'
        },
        agent_inquiry: {
            from: [
                'discovery'
            ],
            to: 'platform_demo',
            action: 'show_platform_features'
        },
        high_intent: {
            from: [
                'qualifying',
                'property_search'
            ],
            to: 'showing_coordination',
            action: 'expedite_booking'
        }
    }
};
}),
"[project]/(chatbot)/app/industries/index.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/modules/chatbot/config/industries/index.ts
__turbopack_context__.s([
    "getAvailableIndustries",
    ()=>getAvailableIndustries,
    "getIndustryDisplayName",
    ()=>getIndustryDisplayName,
    "isValidIndustry",
    ()=>isValidIndustry,
    "loadIndustryConfig",
    ()=>loadIndustryConfig
]);
// Import STRIVE configuration
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$config$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/strive/config.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$system$2d$prompt$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/strive/system-prompt.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$problem$2d$patterns$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/strive/problem-patterns.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$solutions$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/strive/solutions.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$conversation$2d$flow$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/strive/conversation-flow.ts [app-route] (ecmascript)");
// Import REAL ESTATE configuration
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$config$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/real-estate/config.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$system$2d$prompt$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/real-estate/system-prompt.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$problem$2d$patterns$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/real-estate/problem-patterns.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$solutions$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/real-estate/solutions.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$conversation$2d$flow$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/real-estate/conversation-flow.ts [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
async function loadIndustryConfig(industry, clientOverrides) {
    let config;
    // Load industry-specific configuration
    switch(industry){
        case 'strive':
            config = {
                ...__TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$config$2e$json__$28$json$29$__["default"],
                systemPrompt: __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$system$2d$prompt$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["striveSystemPrompt"],
                problemPatterns: __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$problem$2d$patterns$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["striveProblemPatterns"],
                solutions: __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$solutions$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["striveSolutions"],
                conversationFlow: __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$strive$2f$conversation$2d$flow$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["striveConversationFlow"]
            };
            break;
        case 'real-estate':
            config = {
                ...__TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$config$2e$json__$28$json$29$__["default"],
                systemPrompt: __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$system$2d$prompt$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["realEstateSystemPrompt"],
                problemPatterns: __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$problem$2d$patterns$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["realEstateProblemPatterns"],
                solutions: __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$solutions$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["realEstateSolutions"],
                conversationFlow: __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$real$2d$estate$2f$conversation$2d$flow$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["realEstateConversationFlow"]
            };
            break;
        // Future industries will go here
        case 'dental':
            throw new Error('Dental industry not yet implemented');
        case 'legal':
            throw new Error('Legal industry not yet implemented');
        case 'manufacturing':
            throw new Error('Manufacturing industry not yet implemented');
        case 'financial':
            throw new Error('Financial industry not yet implemented');
        case 'retail':
            throw new Error('Retail industry not yet implemented');
        case 'insurance':
            throw new Error('Insurance industry not yet implemented');
        default:
            throw new Error(`Unknown industry: ${industry}`);
    }
    // Apply client-specific overrides if provided
    if (clientOverrides) {
        config = applyClientOverrides(config, clientOverrides);
    }
    return config;
}
/**
 * Apply client-specific customizations to industry config
 */ function applyClientOverrides(config, overrides) {
    return {
        ...config,
        branding: {
            ...config.branding,
            ...overrides.primaryColor && {
                primaryColor: overrides.primaryColor
            },
            ...overrides.secondaryColor && {
                secondaryColor: overrides.secondaryColor
            },
            ...overrides.logo && {
                logo: overrides.logo
            }
        },
        businessInfo: {
            ...config.businessInfo,
            ...overrides.companyName && {
                companyName: overrides.companyName
            },
            ...overrides.calendlyLink && {
                calendlyLink: overrides.calendlyLink
            },
            ...overrides.website && {
                website: overrides.website
            },
            ...overrides.phone && {
                phone: overrides.phone
            }
        }
    };
}
function getAvailableIndustries() {
    return [
        'strive',
        'real-estate'
    ]; // ✅ UPDATED: Added real-estate
}
function isValidIndustry(industry) {
    const validIndustries = [
        'strive',
        'real-estate',
        'dental',
        'legal',
        'manufacturing',
        'financial',
        'retail',
        'insurance'
    ];
    return validIndustries.includes(industry);
}
function getIndustryDisplayName(industry) {
    const names = {
        'strive': 'AI Solutions (STRIVE TECH)',
        'real-estate': 'Real Estate',
        'dental': 'Dental Practice',
        'legal': 'Legal Services',
        'manufacturing': 'Manufacturing',
        'financial': 'Financial Services',
        'retail': 'Retail',
        'insurance': 'Insurance'
    };
    return names[industry];
}
}),
"[project]/(chatbot)/app/services/cache-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/services/cache-service.ts
__turbopack_context__.s([
    "CacheService",
    ()=>CacheService
]);
class CacheService {
    static cache = new Map();
    static DEFAULT_TTL = 3600;
    static cleanupInterval = null;
    /**
   * Set a value in cache with TTL
   */ static set(key, value, ttl = this.DEFAULT_TTL) {
        this.cache.set(key, {
            data: value,
            expires: Date.now() + ttl * 1000
        });
    }
    /**
   * Get a value from cache (returns null if expired or not found)
   */ static get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            return null;
        }
        // Check if expired
        if (entry.expires < Date.now()) {
            this.cache.delete(key);
            return null;
        }
        return entry.data;
    }
    /**
   * Delete a specific key
   */ static delete(key) {
        this.cache.delete(key);
    }
    /**
   * Clear all cache
   */ static clear() {
        this.cache.clear();
    }
    /**
   * Get cache statistics
   */ static getStats() {
        return {
            size: this.cache.size,
            entries: Array.from(this.cache.keys())
        };
    }
    /**
   * Check if a key exists and is not expired
   */ static has(key) {
        const entry = this.cache.get(key);
        if (!entry) return false;
        if (entry.expires < Date.now()) {
            this.cache.delete(key);
            return false;
        }
        return true;
    }
    /**
   * Cleanup expired entries periodically
   */ static startCleanup(intervalMs = 60000) {
        if (this.cleanupInterval) {
            return; // Already running
        }
        this.cleanupInterval = setInterval(()=>{
            const now = Date.now();
            let cleaned = 0;
            for (const [key, entry] of this.cache.entries()){
                if (entry.expires < now) {
                    this.cache.delete(key);
                    cleaned++;
                }
            }
            if (cleaned > 0) {
                console.log(`🧹 Cache cleanup: Removed ${cleaned} expired entries`);
            }
        }, intervalMs);
    }
    /**
   * Stop cleanup interval
   */ static stopCleanup() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
    }
    /**
   * Simple hash function for creating cache keys
   */ static createKey(...parts) {
        return parts.join(':');
    }
}
// Initialize cleanup on server start (only in Node.js environment)
if ("TURBOPACK compile-time truthy", 1) {
    CacheService.startCleanup();
}
}),
"[project]/(chatbot)/app/services/rag-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/services/rag-service.ts
__turbopack_context__.s([
    "RAGService",
    ()=>RAGService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$server$2d$only$2f$empty$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/server-only/empty.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/client.mjs [app-route] (ecmascript) <export OpenAI as default>");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/services/cache-service.ts [app-route] (ecmascript)");
;
;
;
;
const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY);
const openai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__["default"]({
    apiKey: process.env.OPENAI_API_KEY
});
class RAGService {
    /**
   * Generate embedding for text using OpenAI (WITH CACHING)
   */ static async generateEmbedding(text) {
        // ✅ CREATE CACHE KEY
        const cacheKey = __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].createKey('embedding', this.hashText(text));
        // ✅ CHECK CACHE FIRST
        const cached = __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].get(cacheKey);
        if (cached) {
            console.log('✅ Embedding cache HIT - saved $0.0001');
            return cached;
        }
        // ✅ CACHE MISS - Generate new embedding
        console.log('💰 Generating new embedding (costs $0.0001)');
        const response = await openai.embeddings.create({
            model: 'text-embedding-ada-002',
            input: text
        });
        const embedding = response.data[0].embedding;
        // ✅ STORE IN CACHE (24 hours)
        __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].set(cacheKey, embedding, 86400); // 24 hours
        return embedding;
    }
    /**
   * Simple hash function for cache keys
   */ static hashText(text) {
        // Normalize text for caching
        const normalized = text.toLowerCase().trim().replace(/\s+/g, ' ');
        // Simple hash (good enough for caching similar queries)
        let hash = 0;
        for(let i = 0; i < normalized.length; i++){
            const char = normalized.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return `${hash}_${normalized.substring(0, 50)}`;
    }
    /**
   * Search for similar conversations using vector similarity (WITH CACHING)
   */ static async searchSimilarConversations(userMessage, industry, options = {}) {
        const { threshold = 0.75, limit = 5, includeExamples = true } = options;
        // ✅ CHECK RAG CACHE
        const ragCacheKey = __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].createKey('rag', industry, this.hashText(userMessage));
        const cachedResults = __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].get(ragCacheKey);
        if (cachedResults) {
            console.log('✅ RAG search cache HIT');
            return cachedResults;
        }
        console.log('🔍 RAG search cache MISS - performing search');
        // Generate embedding (this will use embedding cache)
        const embedding = await this.generateEmbedding(userMessage);
        // Search actual conversations
        const { data: conversations, error: convError } = await supabase.rpc('match_conversations', {
            query_embedding: embedding,
            match_industry: industry,
            match_threshold: threshold,
            match_count: limit
        });
        if (convError) {
            console.error('Error searching conversations:', convError);
        }
        // Search example conversations
        let examples = [];
        if (includeExamples) {
            const { data: exampleData, error: exError } = await supabase.rpc('match_examples', {
                query_embedding: embedding,
                match_industry: industry,
                match_threshold: threshold,
                match_count: limit
            });
            if (exError) {
                console.error('Error searching examples:', exError);
            } else {
                examples = exampleData || [];
            }
        }
        // Combine and analyze results
        const allResults = [
            ...conversations || [],
            ...examples.map((e)=>({
                    id: e.id,
                    userMessage: e.user_input,
                    assistantResponse: e.assistant_response,
                    problemDetected: e.problem_type,
                    solutionPresented: e.solution_type,
                    outcome: e.outcome,
                    conversionScore: e.conversion_score,
                    similarity: e.similarity
                }))
        ];
        // Extract detected problems
        const problemCounts = new Map();
        allResults.forEach((r)=>{
            if (r.problemDetected) {
                problemCounts.set(r.problemDetected, (problemCounts.get(r.problemDetected) || 0) + 1);
            }
        });
        const detectedProblems = Array.from(problemCounts.entries()).sort((a, b)=>b[1] - a[1]).slice(0, 3).map(([problem])=>problem);
        // Extract recommended solutions
        const solutionCounts = new Map();
        allResults.forEach((r)=>{
            if (r.solutionPresented) {
                solutionCounts.set(r.solutionPresented, (solutionCounts.get(r.solutionPresented) || 0) + 1);
            }
        });
        const recommendedSolutions = Array.from(solutionCounts.entries()).sort((a, b)=>b[1] - a[1]).slice(0, 3).map(([solution])=>solution);
        // Find best response pattern (highest conversion)
        const bestPattern = allResults.filter((r)=>r.conversionScore && r.conversionScore > 0.7).sort((a, b)=>(b.conversionScore || 0) - (a.conversionScore || 0))[0];
        // Calculate confidence scores
        const avgSimilarity = allResults.reduce((sum, r)=>sum + r.similarity, 0) / Math.max(allResults.length, 1);
        const problemConfidence = Math.min(problemCounts.size > 0 ? Math.max(...problemCounts.values()) / allResults.length : 0, 1);
        const solutionConfidence = Math.min(solutionCounts.size > 0 ? Math.max(...solutionCounts.values()) / allResults.length : 0, 1);
        const results = {
            similarConversations: allResults,
            detectedProblems,
            recommendedSolutions,
            bestPattern: bestPattern ? {
                approach: bestPattern.assistantResponse,
                conversionScore: bestPattern.conversionScore || 0,
                stage: 'solutioning'
            } : undefined,
            confidence: {
                problemDetection: problemConfidence,
                solutionMatch: solutionConfidence,
                overallConfidence: (avgSimilarity + problemConfidence + solutionConfidence) / 3
            }
        };
        // ✅ CACHE RAG RESULTS (1 hour)
        __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].set(ragCacheKey, results, 3600);
        return results;
    }
    /**
   * Build enhanced context for Sai
   */ static async buildRAGContext(userMessage, industry, conversationHistory) {
        const searchResults = await this.searchSimilarConversations(userMessage, industry);
        // Generate guidance based on search results
        const guidance = this.generateGuidance(searchResults, conversationHistory);
        return {
            userMessage,
            searchResults,
            conversationHistory,
            guidance
        };
    }
    /**
   * Generate guidance for Sai based on RAG results
   */ static generateGuidance(searchResults, conversationHistory) {
        const { confidence, detectedProblems, bestPattern } = searchResults;
        const keyPoints = [];
        const avoidTopics = [];
        let urgencyLevel = 'low';
        // High confidence - use proven approach
        if (confidence.overallConfidence > 0.8 && bestPattern) {
            keyPoints.push(`Similar conversations with ${Math.round(bestPattern.conversionScore * 100)}% conversion rate used this approach`);
            keyPoints.push('Focus on problem quantification and impact');
        }
        // Medium confidence - suggest exploration
        if (confidence.overallConfidence > 0.5 && confidence.overallConfidence <= 0.8) {
            keyPoints.push('Ask 2-3 discovery questions to clarify the problem');
            keyPoints.push('Avoid premature solution presentation');
        }
        // Low confidence - stay in discovery
        if (confidence.overallConfidence <= 0.5) {
            keyPoints.push('Stay in discovery mode - ask open-ended questions');
            avoidTopics.push('Specific solution recommendations');
        }
        // Detect urgency based on problem patterns
        if (detectedProblems.some((p)=>p.includes('churn') || p.includes('fraud'))) {
            urgencyLevel = 'high';
            keyPoints.push('Emphasize cost of inaction and urgency');
        }
        const suggestedApproach = confidence.overallConfidence > 0.8 ? 'Present solution with proven talking points' : confidence.overallConfidence > 0.5 ? 'Ask qualifying questions to confirm problem' : 'Continue discovery to understand pain points';
        return {
            suggestedApproach,
            keyPoints,
            avoidTopics,
            urgencyLevel
        };
    }
    /**
   * Store conversation with embedding for future learning
   */ static async storeConversation(data) {
        try {
            // Generate embedding for user message (will use cache if available)
            const embedding = await this.generateEmbedding(data.userMessage);
            // Use default org ID if not provided (public chatbot)
            const orgId = data.organizationId || 'public-chatbot-org';
            const { error } = await supabase.from('conversations').insert({
                organization_id: orgId,
                industry: data.industry,
                session_id: data.sessionId,
                user_message: data.userMessage,
                assistant_response: data.assistantResponse,
                embedding: embedding,
                conversation_stage: data.conversationStage,
                outcome: data.outcome,
                problem_detected: data.problemDetected,
                solution_presented: data.solutionPresented,
                conversion_score: data.conversionScore,
                booking_completed: data.bookingCompleted,
                response_time_ms: data.responseTimeMs,
                user_satisfaction: data.userSatisfaction
            });
            if (error) {
                console.error('Failed to store conversation:', error);
            }
        } catch (error) {
            console.error('Failed to store conversation:', error);
        // Don't throw - logging failure shouldn't break chat
        }
    }
    /**
   * Mark conversation as successful (booking completed)
   */ static async markConversationSuccess(sessionId, conversionScore = 1.0) {
        try {
            const { error } = await supabase.from('conversations').update({
                outcome: 'booking_completed',
                booking_completed: true,
                conversion_score: conversionScore,
                updated_at: new Date().toISOString()
            }).eq('session_id', sessionId);
            if (error) {
                console.error('Error marking conversation success:', error);
            }
        } catch (error) {
            console.error('Error marking conversation success:', error);
        }
    }
}
}),
"[project]/shared/lib/services/cache-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// shared/lib/services/cache-service.ts
// Shared in-memory caching service with TTL support
__turbopack_context__.s([
    "CacheService",
    ()=>CacheService
]);
class CacheService {
    static cache = new Map();
    static DEFAULT_TTL = 3600;
    static cleanupInterval = null;
    /**
   * Set a value in cache with TTL
   */ static set(key, value, ttl = this.DEFAULT_TTL) {
        this.cache.set(key, {
            data: value,
            expires: Date.now() + ttl * 1000
        });
    }
    /**
   * Get a value from cache (returns null if expired or not found)
   */ static get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            return null;
        }
        // Check if expired
        if (entry.expires < Date.now()) {
            this.cache.delete(key);
            return null;
        }
        return entry.data;
    }
    /**
   * Delete a specific key
   */ static delete(key) {
        this.cache.delete(key);
    }
    /**
   * Clear all cache
   */ static clear() {
        this.cache.clear();
    }
    /**
   * Get cache statistics
   */ static getStats() {
        return {
            size: this.cache.size,
            entries: Array.from(this.cache.keys())
        };
    }
    /**
   * Check if a key exists and is not expired
   */ static has(key) {
        const entry = this.cache.get(key);
        if (!entry) return false;
        if (entry.expires < Date.now()) {
            this.cache.delete(key);
            return false;
        }
        return true;
    }
    /**
   * Cleanup expired entries periodically
   */ static startCleanup(intervalMs = 60000) {
        if (this.cleanupInterval) {
            return; // Already running
        }
        this.cleanupInterval = setInterval(()=>{
            const now = Date.now();
            let cleaned = 0;
            for (const [key, entry] of this.cache.entries()){
                if (entry.expires < now) {
                    this.cache.delete(key);
                    cleaned++;
                }
            }
            if (cleaned > 0) {
                console.log(`🧹 Cache cleanup: Removed ${cleaned} expired entries`);
            }
        }, intervalMs);
    }
    /**
   * Stop cleanup interval
   */ static stopCleanup() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
    }
    /**
   * Simple hash function for creating cache keys
   */ static createKey(...parts) {
        return parts.join(':');
    }
}
// Initialize cleanup on server start (only in Node.js environment)
if ("TURBOPACK compile-time truthy", 1) {
    CacheService.startCleanup();
}
}),
"[project]/(chatbot)/app/services/rentcast-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// app/lib/modules/real-estate/services/rentcast-service.ts
__turbopack_context__.s([
    "RentCastService",
    ()=>RentCastService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$server$2d$only$2f$empty$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/server-only/empty.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$shared$2f$lib$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/shared/lib/services/cache-service.ts [app-route] (ecmascript)");
;
;
// Environment variable for RentCast API key
const RENTCAST_API_KEY = process.env.RENTCAST_API_KEY;
const RENTCAST_BASE_URL = 'https://api.rentcast.io/v1';
class RentCastService {
    /**
   * Search properties using RentCast API
   */ static async searchProperties(params) {
        // Create cache key based on search params
        const cacheKey = __TURBOPACK__imported__module__$5b$project$5d2f$shared$2f$lib$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].createKey('rentcast', params.location, params.maxPrice.toString(), params.minBedrooms.toString(), params.propertyType || 'any');
        // Check cache first (15 minute TTL for property searches)
        const cached = __TURBOPACK__imported__module__$5b$project$5d2f$shared$2f$lib$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].get(cacheKey);
        if (cached) {
            console.log('✅ RentCast cache HIT');
            return cached;
        }
        console.log('🔍 RentCast cache MISS - fetching from API');
        try {
            // Parse location to get city and state
            const { city, state, zipCode } = this.parseLocation(params.location);
            // Build RentCast API request
            const url = new URL(`${RENTCAST_BASE_URL}/listings/sale`);
            url.searchParams.append('city', city);
            url.searchParams.append('state', state);
            if (zipCode) url.searchParams.append('zipCode', zipCode);
            url.searchParams.append('maxPrice', params.maxPrice.toString());
            url.searchParams.append('bedrooms', params.minBedrooms.toString());
            if (params.minBathrooms) {
                url.searchParams.append('bathrooms', params.minBathrooms.toString());
            }
            if (params.propertyType) {
                url.searchParams.append('propertyType', params.propertyType);
            }
            url.searchParams.append('status', 'Active');
            url.searchParams.append('limit', '50'); // Get more than 5 for better matching
            const response = await fetch(url.toString(), {
                headers: {
                    'X-Api-Key': RENTCAST_API_KEY,
                    'Accept': 'application/json'
                }
            });
            if (!response.ok) {
                throw new Error(`RentCast API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            // Transform RentCast response to our Property format
            const properties = data.map((listing)=>this.transformListing(listing));
            // Cache results for 15 minutes
            __TURBOPACK__imported__module__$5b$project$5d2f$shared$2f$lib$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheService"].set(cacheKey, properties, 900);
            return properties;
        } catch (error) {
            console.error('RentCast API error:', error);
            throw new Error('Failed to fetch property listings. Please try again.');
        }
    }
    /**
   * Enhanced property matching algorithm with intelligent scoring
   */ static matchProperties(properties, params) {
        const matches = [];
        for (const property of properties){
            let score = 0;
            const matchReasons = [];
            const missingFeatures = [];
            // ========================================
            // 1. PRICE MATCHING (Max 35 points)
            // ========================================
            if (property.price > params.maxPrice) continue; // Hard filter - over budget
            const priceDiff = params.maxPrice - property.price;
            const pricePercentUnderBudget = priceDiff / params.maxPrice * 100;
            // Sweet spot: 5-15% under budget gets maximum points
            if (pricePercentUnderBudget >= 5 && pricePercentUnderBudget <= 15) {
                score += 35; // Perfect price range
                matchReasons.push(`Perfect price - $${priceDiff.toLocaleString()} under budget`);
            } else if (pricePercentUnderBudget > 15) {
                score += 25; // Way under budget (might be missing features)
                matchReasons.push(`Great value - well under budget`);
            } else if (pricePercentUnderBudget >= 0) {
                score += 20; // At or slightly under budget
            }
            // ========================================
            // 2. BEDROOM MATCHING (Max 25 points)
            // ========================================
            if (property.bedrooms < params.minBedrooms) continue; // Hard filter
            if (property.bedrooms === params.minBedrooms) {
                score += 25; // Exact match
            } else if (property.bedrooms === params.minBedrooms + 1) {
                score += 30; // One extra bedroom (bonus!)
                matchReasons.push(`${property.bedrooms} bedrooms (bonus room)`);
            } else if (property.bedrooms > params.minBedrooms + 1) {
                score += 20; // Too many bedrooms might mean higher maintenance
                matchReasons.push(`${property.bedrooms} bedrooms (spacious)`);
            }
            // ========================================
            // 3. BATHROOM MATCHING (Max 20 points)
            // ========================================
            if (params.minBathrooms) {
                if (property.bathrooms >= params.minBathrooms) {
                    score += 15;
                    if (property.bathrooms > params.minBathrooms) {
                        score += 5;
                        matchReasons.push(`${property.bathrooms} bathrooms`);
                    }
                }
            } else {
                // No bathroom preference - still reward more bathrooms
                if (property.bathrooms >= 2) {
                    score += 10;
                }
            }
            // ========================================
            // 4. MUST-HAVE FEATURES (Max 40 points)
            // ========================================
            const mustHaveFeatures = params.mustHaveFeatures || [];
            let mustHaveMatches = 0;
            let mustHaveMisses = 0;
            for (const feature of mustHaveFeatures){
                const hasFeature = this.propertyHasFeature(property, feature);
                if (hasFeature) {
                    mustHaveMatches++;
                    score += 15; // High value for must-haves
                    matchReasons.push(`✓ ${this.formatFeature(feature)}`);
                } else {
                    mustHaveMisses++;
                    missingFeatures.push(this.formatFeature(feature));
                    score -= 10; // Heavy penalty for missing must-haves
                }
            }
            // Bonus for having ALL must-haves
            if (mustHaveFeatures.length > 0 && mustHaveMisses === 0) {
                score += 10;
                matchReasons.push('Has all must-have features!');
            }
            // ========================================
            // 5. NICE-TO-HAVE FEATURES (Max 15 points)
            // ========================================
            const niceToHaves = params.niceToHaveFeatures || [];
            let niceToHaveCount = 0;
            for (const feature of niceToHaves){
                if (this.propertyHasFeature(property, feature)) {
                    niceToHaveCount++;
                    score += 5; // Smaller bonus for nice-to-haves
                    matchReasons.push(`+ ${this.formatFeature(feature)}`);
                }
            }
            // ========================================
            // 6. PROPERTY TYPE MATCHING (Max 15 points)
            // ========================================
            if (params.propertyType && params.propertyType !== 'any') {
                const propertyTypeNormalized = property.propertyType?.toLowerCase().replace(/[-\s]/g, '');
                const targetTypeNormalized = params.propertyType.toLowerCase().replace(/[-\s]/g, '');
                if (propertyTypeNormalized?.includes(targetTypeNormalized) || targetTypeNormalized?.includes(propertyTypeNormalized || '')) {
                    score += 15;
                } else {
                    score -= 5; // Small penalty for wrong type
                }
            }
            // ========================================
            // 7. DAYS ON MARKET (Max 15 points)
            // ========================================
            if (property.daysOnMarket <= 3) {
                score += 15;
                matchReasons.push('🔥 Just listed!');
            } else if (property.daysOnMarket <= 7) {
                score += 10;
                matchReasons.push('Recently listed');
            } else if (property.daysOnMarket <= 30) {
                score += 5;
            } else if (property.daysOnMarket > 90) {
                score -= 5; // Been on market a while - might be overpriced
            }
            // ========================================
            // 8. PROPERTY CONDITION (Max 10 points)
            // ========================================
            if (property.yearBuilt) {
                const age = new Date().getFullYear() - property.yearBuilt;
                if (age <= 5) {
                    score += 10;
                    matchReasons.push('Brand new construction');
                } else if (age <= 15) {
                    score += 7;
                    matchReasons.push('Modern build');
                } else if (age <= 30) {
                    score += 3;
                } else if (age > 50) {
                    score -= 3; // Older homes might need work
                }
            }
            // ========================================
            // 9. SCHOOL RATINGS (Max 15 points)
            // ========================================
            if (property.schoolRatings) {
                const avgRating = ((property.schoolRatings.elementary || 0) + (property.schoolRatings.middle || 0) + (property.schoolRatings.high || 0)) / 3;
                if (avgRating >= 9) {
                    score += 15;
                    matchReasons.push('⭐ Exceptional schools nearby');
                } else if (avgRating >= 8) {
                    score += 12;
                    matchReasons.push('Top-rated schools');
                } else if (avgRating >= 7) {
                    score += 8;
                    matchReasons.push('Great schools');
                } else if (avgRating >= 6) {
                    score += 4;
                }
            }
            // ========================================
            // 10. PRICE PER SQFT EFFICIENCY (Max 10 points)
            // ========================================
            if (property.sqft > 0) {
                const pricePerSqft = property.price / property.sqft;
                // Market average varies by location - using $200 as baseline
                const marketAvg = 200;
                if (pricePerSqft < marketAvg * 0.75) {
                    score += 10;
                    matchReasons.push('Excellent value per sqft');
                } else if (pricePerSqft < marketAvg * 0.9) {
                    score += 7;
                    matchReasons.push('Good value');
                } else if (pricePerSqft > marketAvg * 1.2) {
                    score -= 5; // Overpriced per sqft
                }
            }
            // ========================================
            // 11. LOT SIZE (Max 5 points)
            // ========================================
            if (property.lotSize && property.lotSize > 10000) {
                score += 5;
                matchReasons.push('Large lot');
            }
            // Calculate match percentage (0-100%)
            const maxPossibleScore = 200; // Approximate max from all categories
            const matchPercentage = Math.min(Math.round(score / maxPossibleScore * 100), 100);
            matches.push({
                property,
                matchScore: score,
                matchReasons: matchReasons.slice(0, 5),
                missingFeatures
            });
        }
        // Sort by match score (highest first) and return top 5
        return matches.sort((a, b)=>b.matchScore - a.matchScore).slice(0, 5).map((match)=>({
                ...match,
                // Add match percentage for display
                matchScore: Math.max(match.matchScore, 0)
            }));
    }
    /**
   * Check if property has a specific feature
   */ static propertyHasFeature(property, feature) {
        const normalizedFeature = feature.toLowerCase().trim();
        const searchTerms = property.features.concat(property.description || '').join(' ').toLowerCase();
        // Map common feature requests to property attributes
        const featureMap = {
            'backyard': [
                'backyard',
                'yard',
                'outdoor space',
                'patio'
            ],
            'pool': [
                'pool',
                'swimming pool',
                'swim'
            ],
            'garage': [
                'garage',
                'parking',
                'carport'
            ],
            'updated kitchen': [
                'updated kitchen',
                'renovated kitchen',
                'modern kitchen',
                'new kitchen'
            ],
            'fireplace': [
                'fireplace',
                'wood burning'
            ],
            'hardwood floors': [
                'hardwood',
                'wood floor'
            ],
            'stainless appliances': [
                'stainless',
                'stainless steel appliances'
            ],
            'master suite': [
                'master suite',
                'primary suite'
            ],
            'walk-in closet': [
                'walk-in closet',
                'walkin closet'
            ],
            'fenced yard': [
                'fenced',
                'fence'
            ]
        };
        const searchKeys = featureMap[normalizedFeature] || [
            normalizedFeature
        ];
        return searchKeys.some((key)=>searchTerms.includes(key));
    }
    /**
   * Format feature name for display
   */ static formatFeature(feature) {
        return feature.charAt(0).toUpperCase() + feature.slice(1);
    }
    /**
   * Parse location string into components
   */ static parseLocation(location) {
        // Handle formats: "Nashville, TN", "37209", "Nashville TN 37209"
        const parts = location.split(/[,\s]+/).filter(Boolean);
        if (parts.length === 1) {
            // Could be just a zip code
            if (/^\d{5}$/.test(parts[0])) {
                return {
                    city: '',
                    state: '',
                    zipCode: parts[0]
                };
            }
            // Or just a city name
            return {
                city: parts[0],
                state: ''
            };
        }
        if (parts.length === 2) {
            return {
                city: parts[0],
                state: parts[1]
            };
        }
        // "Nashville TN 37209"
        return {
            city: parts[0],
            state: parts[1],
            zipCode: parts[2]
        };
    }
    /**
   * Transform RentCast listing to our Property format
   */ static transformListing(listing) {
        return {
            id: listing.id || listing.listingId,
            address: listing.addressLine1 || listing.address,
            city: listing.city,
            state: listing.state,
            zipCode: listing.zipCode,
            price: listing.price,
            bedrooms: listing.bedrooms,
            bathrooms: listing.bathrooms,
            sqft: listing.squareFootage || listing.livingArea,
            lotSize: listing.lotSize,
            propertyType: listing.propertyType,
            yearBuilt: listing.yearBuilt,
            features: listing.features || this.extractFeatures(listing.description),
            images: listing.photos?.map((p)=>p.href || p.url) || [],
            daysOnMarket: this.calculateDaysOnMarket(listing.listDate),
            listingDate: listing.listDate,
            description: listing.description,
            schoolRatings: listing.schools ? {
                elementary: listing.schools.elementary?.rating,
                middle: listing.schools.middle?.rating,
                high: listing.schools.high?.rating
            } : undefined,
            mlsId: listing.mlsId,
            agentInfo: listing.listingAgent ? {
                name: listing.listingAgent.name,
                phone: listing.listingAgent.phone,
                email: listing.listingAgent.email
            } : undefined
        };
    }
    /**
   * Extract features from description text
   */ static extractFeatures(description) {
        if (!description) return [];
        const features = [];
        const lowerDesc = description.toLowerCase();
        const featurePatterns = [
            'pool',
            'backyard',
            'garage',
            'fireplace',
            'hardwood',
            'granite',
            'stainless',
            'updated',
            'renovated',
            'new'
        ];
        for (const pattern of featurePatterns){
            if (lowerDesc.includes(pattern)) {
                features.push(pattern);
            }
        }
        return features;
    }
    /**
   * Calculate days on market
   */ static calculateDaysOnMarket(listDate) {
        const listed = new Date(listDate);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - listed.getTime());
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays;
    }
}
}),
"[project]/(chatbot)/app/schemas/chat-request.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChatRequestSchema",
    ()=>ChatRequestSchema,
    "MessageSchema",
    ()=>MessageSchema
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
const MessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
        'user',
        'assistant',
        'system'
    ]),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1).max(10000),
    timestamp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
const ChatRequestSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    messages: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(MessageSchema).min(1).max(50),
    industry: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default('strive'),
    sessionId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1),
    organizationId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    conversationStage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    detectedProblems: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).optional(),
    clientId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
}),
"[project]/(chatbot)/lib/ai/data-extraction.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/ai/data-extraction.ts
__turbopack_context__.s([
    "ContactInfoSchema",
    ()=>ContactInfoSchema,
    "PropertyPreferencesSchema",
    ()=>PropertyPreferencesSchema,
    "extractDataFromMessage",
    ()=>extractDataFromMessage,
    "formatPreferences",
    ()=>formatPreferences,
    "getMissingCriticalFields",
    ()=>getMissingCriticalFields,
    "hasMinimumSearchCriteria",
    ()=>hasMinimumSearchCriteria,
    "mergeExtractedData",
    ()=>mergeExtractedData
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$server$2d$only$2f$empty$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/server-only/empty.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$groq$2d$sdk$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/groq-sdk/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
const groq = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$groq$2d$sdk$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]({
    apiKey: process.env.GROQ_API_KEY
});
const PropertyPreferencesSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    location: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional().describe('City, state, zip code, or neighborhood'),
    maxPrice: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().positive().optional().describe('Maximum budget in dollars'),
    minBedrooms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int().positive().optional().describe('Minimum number of bedrooms'),
    minBathrooms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().positive().optional().describe('Minimum number of bathrooms'),
    mustHaveFeatures: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).optional().describe('Must-have features like pool, backyard, garage'),
    niceToHaveFeatures: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).optional().describe('Nice-to-have features'),
    propertyType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
        'single-family',
        'condo',
        'townhouse',
        'multi-family',
        'any'
    ]).optional().describe('Type of property'),
    timeline: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
        'ASAP',
        'WITHIN_1_MONTH',
        'WITHIN_3_MONTHS',
        'WITHIN_6_MONTHS',
        'FLEXIBLE'
    ]).optional().describe('How soon they want to move'),
    isFirstTimeBuyer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional().describe('Is this their first home purchase'),
    currentSituation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
        'renting',
        'selling',
        'first-time',
        'relocating',
        'unknown'
    ]).optional().describe('Current living situation')
});
const ContactInfoSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional().describe('Full name'),
    email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().email().optional().describe('Email address'),
    phone: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional().describe('Phone number')
});
async function extractDataFromMessage(userMessage, conversationHistory = []) {
    try {
        // Use Groq with function calling for fast, structured extraction
        const completion = await groq.chat.completions.create({
            model: 'llama-3.3-70b-versatile',
            temperature: 0.1,
            messages: [
                {
                    role: 'system',
                    content: `You are a data extraction assistant for a real estate chatbot.
Extract property search preferences and contact information from user messages.

IMPORTANT EXTRACTION RULES:

1. LOCATION:
   - Extract city, state, zip codes
   - Examples: "Nashville, TN", "Austin", "37209", "Denver, Colorado"

2. PRICE/BUDGET:
   - Convert shorthand to full numbers: "$500k" → 500000, "$1.2M" → 1200000
   - Examples: "$700k", "$850,000", "under $1 million"

3. BEDROOMS/BATHROOMS:
   - Extract from phrases like: "3 bed", "4 bedroom", "3BR", "2.5 bath"
   - Examples: "3 bed 2 bath", "4BR/3BA"

4. FEATURES:
   - Extract mentioned amenities: pool, backyard, garage, fireplace, etc.
   - Map variations: "yard" → "backyard", "2 car garage" → "garage"

5. PROPERTY TYPE:
   - Detect: single-family, condo, townhouse, multi-family
   - "house" → single-family, "apartment" → condo

6. TIMELINE:
   - "ASAP" → immediate need
   - "next month" → WITHIN_1_MONTH
   - "6 months" → WITHIN_6_MONTHS
   - "flexible" → FLEXIBLE

7. CONTACT INFO:
   - Extract names, emails, phone numbers when provided
   - Be liberal in extraction but validate formats

Only extract information explicitly mentioned or strongly implied in the current message.
Do NOT make assumptions beyond what's stated.`
                },
                ...conversationHistory.map((msg)=>({
                        role: msg.role,
                        content: msg.content
                    })),
                {
                    role: 'user',
                    content: userMessage
                }
            ],
            tools: [
                {
                    type: 'function',
                    function: {
                        name: 'extract_property_preferences',
                        description: 'Extract property search preferences from user message',
                        parameters: {
                            type: 'object',
                            properties: {
                                location: {
                                    type: 'string',
                                    description: 'City, state, zip code, or neighborhood (e.g., "Nashville, TN", "37209")'
                                },
                                maxPrice: {
                                    type: 'number',
                                    description: 'Maximum budget in dollars (convert "500k" to 500000)'
                                },
                                minBedrooms: {
                                    type: 'integer',
                                    description: 'Minimum number of bedrooms'
                                },
                                minBathrooms: {
                                    type: 'number',
                                    description: 'Minimum number of bathrooms (can be decimal like 2.5)'
                                },
                                mustHaveFeatures: {
                                    type: 'array',
                                    items: {
                                        type: 'string'
                                    },
                                    description: 'Must-have features (pool, backyard, garage, etc.)'
                                },
                                niceToHaveFeatures: {
                                    type: 'array',
                                    items: {
                                        type: 'string'
                                    },
                                    description: 'Nice-to-have features'
                                },
                                propertyType: {
                                    type: 'string',
                                    enum: [
                                        'single-family',
                                        'condo',
                                        'townhouse',
                                        'multi-family',
                                        'any'
                                    ],
                                    description: 'Type of property desired'
                                },
                                timeline: {
                                    type: 'string',
                                    enum: [
                                        'ASAP',
                                        'WITHIN_1_MONTH',
                                        'WITHIN_3_MONTHS',
                                        'WITHIN_6_MONTHS',
                                        'FLEXIBLE'
                                    ],
                                    description: 'Timeline for moving/purchasing'
                                },
                                isFirstTimeBuyer: {
                                    type: 'boolean',
                                    description: 'Is this a first-time home buyer?'
                                },
                                currentSituation: {
                                    type: 'string',
                                    enum: [
                                        'renting',
                                        'selling',
                                        'first-time',
                                        'relocating',
                                        'unknown'
                                    ],
                                    description: 'Current living situation'
                                }
                            }
                        }
                    }
                },
                {
                    type: 'function',
                    function: {
                        name: 'extract_contact_info',
                        description: 'Extract contact information from user message',
                        parameters: {
                            type: 'object',
                            properties: {
                                name: {
                                    type: 'string',
                                    description: 'Full name'
                                },
                                email: {
                                    type: 'string',
                                    description: 'Email address'
                                },
                                phone: {
                                    type: 'string',
                                    description: 'Phone number'
                                }
                            }
                        }
                    }
                }
            ],
            tool_choice: 'auto'
        });
        const responseMessage = completion.choices[0]?.message;
        const toolCalls = responseMessage?.tool_calls || [];
        let propertyPreferences = {};
        let contactInfo = {};
        const extractedFields = [];
        let confidence = 0.8; // Default confidence
        // Process tool calls
        for (const toolCall of toolCalls){
            const functionName = toolCall.function.name;
            const args = JSON.parse(toolCall.function.arguments);
            if (functionName === 'extract_property_preferences') {
                propertyPreferences = PropertyPreferencesSchema.parse(args);
                extractedFields.push(...Object.keys(args).filter((k)=>args[k] !== undefined && args[k] !== null));
            } else if (functionName === 'extract_contact_info') {
                contactInfo = ContactInfoSchema.parse(args);
                extractedFields.push(...Object.keys(args).filter((k)=>args[k] !== undefined && args[k] !== null));
            }
        }
        // Calculate confidence based on number of fields extracted
        if (extractedFields.length > 0) {
            confidence = Math.min(0.9, 0.6 + extractedFields.length * 0.1);
        }
        return {
            propertyPreferences,
            contactInfo,
            extractedFields: [
                ...new Set(extractedFields)
            ],
            confidence
        };
    } catch (error) {
        console.error('❌ Data extraction error:', error);
        // Fallback to regex-based extraction if AI fails
        return fallbackExtraction(userMessage);
    }
}
/**
 * Fallback extraction using regex patterns (when AI extraction fails)
 */ function fallbackExtraction(message) {
    const propertyPreferences = {};
    const contactInfo = {};
    const extractedFields = [];
    // Extract price
    const priceMatch = message.match(/\$?([\d,]+)k?(?:,000)?(?:\s*(?:max|budget|price|under|up to))?/i);
    if (priceMatch) {
        let amount = parseInt(priceMatch[1].replace(/,/g, ''));
        if (message.toLowerCase().includes('k') && amount < 10000) {
            amount *= 1000;
        }
        propertyPreferences.maxPrice = amount;
        extractedFields.push('maxPrice');
    }
    // Extract bedrooms
    const bedroomsMatch = message.match(/(\d+)\s*(?:bed|br|bedroom)/i);
    if (bedroomsMatch) {
        propertyPreferences.minBedrooms = parseInt(bedroomsMatch[1]);
        extractedFields.push('minBedrooms');
    }
    // Extract bathrooms
    const bathroomsMatch = message.match(/(\d+(?:\.\d+)?)\s*(?:bath|ba|bathroom)/i);
    if (bathroomsMatch) {
        propertyPreferences.minBathrooms = parseFloat(bathroomsMatch[1]);
        extractedFields.push('minBathrooms');
    }
    // Extract features
    const features = [];
    if (/\bpool\b/i.test(message)) features.push('pool');
    if (/\b(?:backyard|yard)\b/i.test(message)) features.push('backyard');
    if (/\bgarage\b/i.test(message)) features.push('garage');
    if (/\bfireplace\b/i.test(message)) features.push('fireplace');
    if (features.length > 0) {
        propertyPreferences.mustHaveFeatures = features;
        extractedFields.push('mustHaveFeatures');
    }
    // Extract property type
    if (/\b(?:single-family|house|home)\b/i.test(message)) {
        propertyPreferences.propertyType = 'single-family';
        extractedFields.push('propertyType');
    } else if (/\bcondo\b/i.test(message)) {
        propertyPreferences.propertyType = 'condo';
        extractedFields.push('propertyType');
    } else if (/\btownhouse\b/i.test(message)) {
        propertyPreferences.propertyType = 'townhouse';
        extractedFields.push('propertyType');
    }
    // Extract email
    const emailMatch = message.match(/[\w.-]+@[\w.-]+\.\w+/);
    if (emailMatch) {
        contactInfo.email = emailMatch[0];
        extractedFields.push('email');
    }
    // Extract phone
    const phoneMatch = message.match(/\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/);
    if (phoneMatch) {
        contactInfo.phone = phoneMatch[0];
        extractedFields.push('phone');
    }
    return {
        propertyPreferences,
        contactInfo,
        extractedFields,
        confidence: extractedFields.length > 0 ? 0.6 : 0.3
    };
}
function mergeExtractedData(existing, extracted) {
    return {
        ...existing,
        ...Object.fromEntries(Object.entries(extracted).filter(([_, value])=>value !== undefined && value !== null))
    };
}
function hasMinimumSearchCriteria(preferences) {
    return !!(preferences.location && preferences.maxPrice);
}
function getMissingCriticalFields(preferences) {
    const missing = [];
    if (!preferences.location) missing.push('location');
    if (!preferences.maxPrice) missing.push('budget');
    return missing;
}
function formatPreferences(preferences) {
    const parts = [];
    if (preferences.location) parts.push(`📍 ${preferences.location}`);
    if (preferences.maxPrice) parts.push(`💰 $${preferences.maxPrice.toLocaleString()}`);
    if (preferences.minBedrooms) parts.push(`🛏️ ${preferences.minBedrooms}+ bed`);
    if (preferences.minBathrooms) parts.push(`🛁 ${preferences.minBathrooms}+ bath`);
    if (preferences.propertyType) parts.push(`🏠 ${preferences.propertyType}`);
    if (preferences.mustHaveFeatures && preferences.mustHaveFeatures.length > 0) {
        parts.push(`✨ ${preferences.mustHaveFeatures.join(', ')}`);
    }
    return parts.join(' | ');
}
}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}),
"[project]/(chatbot)/lib/services/crm-integration.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/services/crm-integration.ts
__turbopack_context__.s([
    "LeadScore",
    ()=>LeadScore,
    "getLeadSummary",
    ()=>getLeadSummary,
    "logActivity",
    ()=>logActivity,
    "requestShowing",
    ()=>requestShowing,
    "syncLeadToCRM",
    ()=>syncLeadToCRM,
    "trackPropertyView",
    ()=>trackPropertyView
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$server$2d$only$2f$empty$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/server-only/empty.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
;
const prisma = new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]();
var LeadScore = /*#__PURE__*/ function(LeadScore) {
    LeadScore["COLD"] = "COLD";
    LeadScore["WARM"] = "WARM";
    LeadScore["HOT"] = "HOT";
    LeadScore["QUALIFIED"] = "QUALIFIED";
    return LeadScore;
}({});
/**
 * Calculate lead score based on conversation engagement
 */ function calculateLeadScore(messageCount, hasContactInfo, hasCompleteCriteria, viewedProperties, budget) {
    let scoreValue = 0;
    // Engagement points
    scoreValue += messageCount * 5; // 5 points per message
    if (hasContactInfo) scoreValue += 30; // Big boost for contact info
    if (hasCompleteCriteria) scoreValue += 20; // Complete search criteria
    scoreValue += viewedProperties * 10; // 10 points per property viewed
    // Budget qualifier
    if (budget && budget >= 500000) scoreValue += 15; // Higher budget = more serious
    // Determine score tier
    let score;
    if (scoreValue >= 80 && hasContactInfo) {
        score = "QUALIFIED"; // Ready for agent contact
    } else if (scoreValue >= 50) {
        score = "HOT"; // Very engaged
    } else if (scoreValue >= 25) {
        score = "WARM"; // Moderately engaged
    } else {
        score = "COLD"; // Just started
    }
    return {
        score,
        scoreValue
    };
}
/**
 * Determine lead status based on conversation stage
 */ function determineLeadStatus(canSearch, hasSearched, hasScheduledShowing) {
    if (hasScheduledShowing) return 'CONTACTED'; // Agent engaged
    if (hasSearched) return 'QUALIFIED'; // Saw properties
    if (canSearch) return 'WORKING'; // Has criteria, ready to search
    return 'NEW_LEAD'; // Just started conversation
}
async function syncLeadToCRM(params) {
    const { sessionId, organizationId, contactInfo, propertyPreferences, messageCount, hasSearched = false, viewedProperties = [], lastMessage } = params;
    try {
        // Check if lead already exists for this session
        const existingLead = await prisma.leads.findFirst({
            where: {
                organization_id: organizationId,
                custom_fields: {
                    path: [
                        'chatbot_session_id'
                    ],
                    equals: sessionId
                }
            }
        });
        // Calculate lead score
        const hasContactInfo = !!(contactInfo?.email || contactInfo?.phone || contactInfo?.name);
        const hasCompleteCriteria = !!(propertyPreferences?.location && propertyPreferences?.maxPrice);
        const { score, scoreValue } = calculateLeadScore(messageCount, hasContactInfo, hasCompleteCriteria, viewedProperties.length, propertyPreferences?.maxPrice);
        // Determine status
        const status = determineLeadStatus(hasCompleteCriteria, hasSearched, false);
        // Build custom fields JSON
        const customFields = {
            chatbot_session_id: sessionId,
            property_preferences: propertyPreferences ? {
                location: propertyPreferences.location,
                maxPrice: propertyPreferences.maxPrice,
                minBedrooms: propertyPreferences.minBedrooms,
                minBathrooms: propertyPreferences.minBathrooms,
                mustHaveFeatures: propertyPreferences.mustHaveFeatures || [],
                niceToHaveFeatures: propertyPreferences.niceToHaveFeatures || [],
                propertyType: propertyPreferences.propertyType,
                timeline: propertyPreferences.timeline,
                isFirstTimeBuyer: propertyPreferences.isFirstTimeBuyer,
                currentSituation: propertyPreferences.currentSituation
            } : undefined,
            last_property_search: hasSearched ? new Date().toISOString() : undefined,
            viewed_properties: viewedProperties,
            chatbot_engagement: {
                message_count: messageCount,
                last_message: lastMessage,
                last_interaction: new Date().toISOString()
            }
        };
        if (existingLead) {
            // Update existing lead
            const updatedLead = await prisma.leads.update({
                where: {
                    id: existingLead.id
                },
                data: {
                    name: contactInfo?.name || existingLead.name,
                    email: contactInfo?.email || existingLead.email,
                    phone: contactInfo?.phone || existingLead.phone,
                    budget: propertyPreferences?.maxPrice ? propertyPreferences.maxPrice.toString() : existingLead.budget,
                    timeline: propertyPreferences?.timeline || existingLead.timeline,
                    score: score,
                    score_value: scoreValue,
                    status: status,
                    notes: `Last message: "${lastMessage.slice(0, 200)}"`,
                    custom_fields: customFields,
                    last_contact_at: new Date(),
                    updated_at: new Date()
                }
            });
            console.log(`✅ Updated lead ${updatedLead.id} (score: ${score}, status: ${status})`);
            return {
                leadId: updatedLead.id,
                isNew: false
            };
        } else {
            // Create new lead
            const newLead = await prisma.leads.create({
                data: {
                    organization_id: organizationId,
                    name: contactInfo?.name || 'Chatbot Lead',
                    email: contactInfo?.email || undefined,
                    phone: contactInfo?.phone || undefined,
                    source: 'CHATBOT',
                    status: status,
                    score: score,
                    score_value: scoreValue,
                    budget: propertyPreferences?.maxPrice ? propertyPreferences.maxPrice.toString() : undefined,
                    timeline: propertyPreferences?.timeline,
                    notes: `First message: "${lastMessage.slice(0, 200)}"`,
                    tags: [
                        'chatbot',
                        'real-estate'
                    ],
                    custom_fields: customFields,
                    last_contact_at: new Date()
                }
            });
            console.log(`✅ Created new lead ${newLead.id} (score: ${score}, status: ${status})`);
            return {
                leadId: newLead.id,
                isNew: true
            };
        }
    } catch (error) {
        console.error('❌ CRM sync error:', error);
        throw new Error('Failed to sync lead to CRM');
    }
}
async function logActivity(params) {
    const { organizationId, leadId, activityType, description, metadata } = params;
    try {
        // Find the lead to get assigned user
        const lead = await prisma.leads.findUnique({
            where: {
                id: leadId
            },
            select: {
                assigned_to_id: true
            }
        });
        await prisma.activities.create({
            data: {
                organization_id: organizationId,
                lead_id: leadId,
                contact_id: undefined,
                type: activityType === 'message' ? 'NOTE' : 'CALL',
                title: `Chatbot: ${activityType}`,
                description,
                metadata: metadata,
                completed_at: new Date(),
                assigned_to_id: lead?.assigned_to_id || undefined
            }
        });
        console.log(`📝 Logged activity: ${activityType} for lead ${leadId}`);
    } catch (error) {
        console.error('❌ Activity logging error:', error);
    // Don't throw - activity logging is non-critical
    }
}
async function trackPropertyView(params) {
    const { sessionId, organizationId, propertyId, propertyAddress } = params;
    try {
        // Find lead by session
        const lead = await prisma.leads.findFirst({
            where: {
                organization_id: organizationId,
                custom_fields: {
                    path: [
                        'chatbot_session_id'
                    ],
                    equals: sessionId
                }
            }
        });
        if (!lead) {
            console.warn('⚠️ No lead found for property view tracking');
            return;
        }
        // Update viewed properties
        const customFields = lead.custom_fields;
        const viewedProperties = customFields?.viewed_properties || [];
        if (!viewedProperties.includes(propertyId)) {
            viewedProperties.push(propertyId);
            await prisma.leads.update({
                where: {
                    id: lead.id
                },
                data: {
                    custom_fields: {
                        ...customFields,
                        viewed_properties: viewedProperties
                    }
                }
            });
            // Log activity
            await logActivity({
                organizationId,
                leadId: lead.id,
                activityType: 'property_view',
                description: `Viewed property: ${propertyAddress}`,
                metadata: {
                    property_id: propertyId,
                    property_address: propertyAddress
                }
            });
        }
    } catch (error) {
        console.error('❌ Property view tracking error:', error);
    // Don't throw - tracking is non-critical
    }
}
async function requestShowing(params) {
    const { sessionId, organizationId, propertyId, propertyAddress, requestedDate, requestedTime } = params;
    try {
        // Find lead by session
        const lead = await prisma.leads.findFirst({
            where: {
                organization_id: organizationId,
                custom_fields: {
                    path: [
                        'chatbot_session_id'
                    ],
                    equals: sessionId
                }
            }
        });
        if (!lead) {
            throw new Error('Lead not found for showing request');
        }
        // Find or assign default agent
        const assignedAgent = lead.assigned_to_id || await getDefaultAgent(organizationId);
        if (!assignedAgent) {
            throw new Error('No agent available for showing');
        }
        // Create appointment (showing request)
        const appointment = await prisma.appointments.create({
            data: {
                organization_id: organizationId,
                contact_id: undefined,
                assigned_to: assignedAgent,
                title: `Property Showing: ${propertyAddress}`,
                description: `Chatbot showing request for property ${propertyId}\nRequested by: ${lead.name || 'Unknown'}\nEmail: ${lead.email || 'N/A'}\nPhone: ${lead.phone || 'N/A'}`,
                start_time: requestedDate || new Date(Date.now() + 24 * 60 * 60 * 1000),
                end_time: requestedDate ? new Date(requestedDate.getTime() + 60 * 60 * 1000) : new Date(Date.now() + 25 * 60 * 60 * 1000),
                status: 'PENDING',
                location: propertyAddress
            }
        });
        // Update lead status
        await prisma.leads.update({
            where: {
                id: lead.id
            },
            data: {
                status: 'CONTACTED',
                score: "QUALIFIED"
            }
        });
        // Log activity
        await logActivity({
            organizationId,
            leadId: lead.id,
            activityType: 'showing_request',
            description: `Requested showing for ${propertyAddress}${requestedDate ? ` on ${requestedDate.toDateString()}` : ''}`,
            metadata: {
                property_id: propertyId,
                property_address: propertyAddress,
                appointment_id: appointment.id
            }
        });
        console.log(`📅 Created showing request ${appointment.id} for lead ${lead.id}`);
        return {
            appointmentId: appointment.id
        };
    } catch (error) {
        console.error('❌ Showing request error:', error);
        throw new Error('Failed to create showing request');
    }
}
/**
 * Get default agent for organization (for auto-assignment)
 */ async function getDefaultAgent(organizationId) {
    try {
        // Find first active admin or employee
        const user = await prisma.users.findFirst({
            where: {
                organization_id: organizationId,
                role: {
                    in: [
                        'ADMIN',
                        'EMPLOYEE'
                    ]
                }
            },
            orderBy: {
                created_at: 'asc'
            }
        });
        return user?.id || null;
    } catch (error) {
        console.error('❌ Default agent lookup error:', error);
        return null;
    }
}
async function getLeadSummary(sessionId, organizationId) {
    try {
        const lead = await prisma.leads.findFirst({
            where: {
                organization_id: organizationId,
                custom_fields: {
                    path: [
                        'chatbot_session_id'
                    ],
                    equals: sessionId
                }
            }
        });
        if (!lead) {
            throw new Error('Lead not found');
        }
        const customFields = lead.custom_fields;
        const preferences = customFields?.property_preferences || null;
        const engagement = customFields?.chatbot_engagement || {};
        const viewedProperties = customFields?.viewed_properties || [];
        return {
            lead,
            preferences,
            engagementMetrics: {
                messageCount: engagement.message_count || 0,
                viewedProperties: viewedProperties.length,
                score: lead.score,
                status: lead.status
            }
        };
    } catch (error) {
        console.error('❌ Lead summary error:', error);
        throw new Error('Failed to get lead summary');
    }
}
}),
"[project]/(chatbot)/app/api/chat/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// app/api/chat/route.ts
__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$groq$2d$sdk$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/groq-sdk/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/industries/index.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$rag$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/services/rag-service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$rentcast$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/services/rentcast-service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$schemas$2f$chat$2d$request$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/app/schemas/chat-request.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$ai$2f$data$2d$extraction$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/lib/ai/data-extraction.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$services$2f$crm$2d$integration$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/(chatbot)/lib/services/crm-integration.ts [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
const groq = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$groq$2d$sdk$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]({
    apiKey: process.env.GROQ_API_KEY
});
// Session state cache (in production, use Redis or database)
const sessionStateCache = new Map();
async function POST(req) {
    try {
        // Parse and validate request body
        const body = await req.json();
        const validated = __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$schemas$2f$chat$2d$request$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ChatRequestSchema"].parse(body);
        const { messages, industry = 'strive', sessionId, organizationId = 'default_org' } = validated;
        // Load industry configuration
        const config = await (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$industries$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["loadIndustryConfig"])(industry);
        // Get the latest user message
        const latestUserMessage = messages[messages.length - 1];
        // 🎯 PHASE 1: INTELLIGENT DATA EXTRACTION
        console.log('🧠 Extracting data from user message...');
        const extraction = await (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$ai$2f$data$2d$extraction$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractDataFromMessage"])(latestUserMessage.content, messages.slice(-5).map((m)=>({
                role: m.role,
                content: m.content
            })));
        console.log('✅ Extracted:', {
            fields: extraction.extractedFields,
            confidence: extraction.confidence,
            preferences: (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$ai$2f$data$2d$extraction$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatPreferences"])(extraction.propertyPreferences)
        });
        // Get or initialize session state
        let sessionPreferences = sessionStateCache.get(sessionId) || {};
        // Merge extracted data with existing session state
        sessionPreferences = (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$ai$2f$data$2d$extraction$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergeExtractedData"])(sessionPreferences, extraction.propertyPreferences);
        sessionStateCache.set(sessionId, sessionPreferences);
        console.log('💾 Current session state:', (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$ai$2f$data$2d$extraction$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["formatPreferences"])(sessionPreferences));
        // Check if we can search now
        const canSearchNow = (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$ai$2f$data$2d$extraction$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hasMinimumSearchCriteria"])(sessionPreferences);
        console.log('🔍 Can search:', canSearchNow);
        // Build conversation history context
        const conversationHistory = {
            stage: determineConversationStage(messages),
            messageCount: messages.length,
            problemsDiscussed: extractProblemsDiscussed(messages),
            currentPreferences: sessionPreferences,
            extractedThisMessage: extraction.extractedFields,
            canSearch: canSearchNow
        };
        // 🔥 RAG ENHANCEMENT: Get semantic context
        console.log('🔍 Searching for similar conversations...');
        const ragContext = await __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$rag$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RAGService"].buildRAGContext(latestUserMessage.content, industry, conversationHistory);
        console.log('✅ RAG Context:', {
            detectedProblems: ragContext.searchResults.detectedProblems,
            confidence: ragContext.searchResults.confidence.overallConfidence,
            suggestedApproach: ragContext.guidance.suggestedApproach
        });
        // Build enhanced system prompt with RAG context AND extracted data
        const enhancedSystemPrompt = buildEnhancedSystemPrompt(config.systemPrompt, ragContext, sessionPreferences, extraction.extractedFields, canSearchNow);
        // Prepare messages for Groq
        const groqMessages = [
            {
                role: 'system',
                content: enhancedSystemPrompt
            },
            ...messages.filter((m)=>m.role !== 'system').map((m)=>({
                    role: m.role,
                    content: m.content
                }))
        ];
        // Stream response from Groq
        const stream = await groq.chat.completions.create({
            model: 'llama-3.3-70b-versatile',
            messages: groqMessages,
            temperature: 0.7,
            max_tokens: 2000,
            stream: true
        });
        // Create readable stream
        const encoder = new TextEncoder();
        let fullResponse = '';
        const readableStream = new ReadableStream({
            async start (controller) {
                try {
                    // Stream LLM response
                    for await (const chunk of stream){
                        const content = chunk.choices[0]?.delta?.content || '';
                        fullResponse += content;
                        controller.enqueue(encoder.encode(`data: ${JSON.stringify({
                            content
                        })}\n\n`));
                    }
                    // 🏠 PROPERTY SEARCH: Check if response contains property search request OR if we can auto-search
                    const shouldSearch = industry === 'real-estate' && (fullResponse.includes('<property_search>') || canSearchNow);
                    if (shouldSearch) {
                        try {
                            console.log('🏠 Property search triggered');
                            let searchParams;
                            // Check if AI provided explicit search parameters
                            const searchMatch = fullResponse.match(/<property_search>([\s\S]*?)<\/property_search>/);
                            if (searchMatch) {
                                // AI provided explicit search params
                                searchParams = JSON.parse(searchMatch[1]);
                                console.log('🔍 Using AI-provided search params:', searchParams);
                            } else if (canSearchNow) {
                                // Auto-search using extracted session state
                                searchParams = {
                                    location: sessionPreferences.location,
                                    maxPrice: sessionPreferences.maxPrice,
                                    minBedrooms: sessionPreferences.minBedrooms || 2,
                                    minBathrooms: sessionPreferences.minBathrooms || 1,
                                    mustHaveFeatures: sessionPreferences.mustHaveFeatures || [],
                                    niceToHaveFeatures: sessionPreferences.niceToHaveFeatures,
                                    propertyType: sessionPreferences.propertyType === 'any' ? undefined : sessionPreferences.propertyType
                                };
                                console.log('🔍 Auto-searching with extracted params:', searchParams);
                            } else {
                                // Skip search
                                throw new Error('Cannot search: minimum criteria not met');
                            }
                            // Fetch properties from RentCast
                            const properties = await __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$rentcast$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RentCastService"].searchProperties(searchParams);
                            console.log(`✅ Found ${properties.length} properties`);
                            // Match and score properties
                            const matches = __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$rentcast$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RentCastService"].matchProperties(properties, searchParams);
                            console.log(`🎯 Top ${matches.length} matches selected`);
                            // Send property results to client
                            const propertyData = JSON.stringify({
                                type: 'property_results',
                                properties: matches
                            });
                            controller.enqueue(encoder.encode(`data: ${propertyData}\n\n`));
                        } catch (propertyError) {
                            console.error('❌ Property search error:', propertyError);
                            const errorData = JSON.stringify({
                                type: 'property_search_error',
                                error: 'Failed to search properties. Please try again.'
                            });
                            controller.enqueue(encoder.encode(`data: ${errorData}\n\n`));
                        }
                    }
                    // 🔥 STORE CONVERSATION: Save for future learning
                    console.log('💾 Storing conversation for learning...');
                    await __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$app$2f$services$2f$rag$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RAGService"].storeConversation({
                        industry,
                        sessionId,
                        userMessage: latestUserMessage.content,
                        assistantResponse: fullResponse,
                        conversationStage: conversationHistory.stage,
                        outcome: 'in_progress',
                        bookingCompleted: false,
                        problemDetected: ragContext.searchResults.detectedProblems[0],
                        solutionPresented: ragContext.searchResults.recommendedSolutions[0]
                    });
                    // 💼 CRM INTEGRATION: Sync lead to platform CRM
                    if (industry === 'real-estate') {
                        try {
                            console.log('💼 Syncing lead to CRM...');
                            const { leadId, isNew } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$services$2f$crm$2d$integration$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncLeadToCRM"])({
                                sessionId,
                                organizationId,
                                contactInfo: extraction.contactInfo,
                                propertyPreferences: sessionPreferences,
                                messageCount: messages.length,
                                hasSearched: shouldSearch,
                                viewedProperties: [],
                                lastMessage: latestUserMessage.content
                            });
                            console.log(`✅ ${isNew ? 'Created' : 'Updated'} lead ${leadId} in CRM`);
                            // Log conversation activity
                            await (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$services$2f$crm$2d$integration$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logActivity"])({
                                organizationId,
                                leadId,
                                activityType: 'message',
                                description: `Chatbot conversation: "${latestUserMessage.content.slice(0, 100)}..."`,
                                metadata: {
                                    extracted_fields: extraction.extractedFields,
                                    can_search: canSearchNow,
                                    preferences: sessionPreferences
                                }
                            });
                            // Log property search activity if triggered
                            if (shouldSearch) {
                                await (0, __TURBOPACK__imported__module__$5b$project$5d2f28$chatbot$292f$lib$2f$services$2f$crm$2d$integration$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logActivity"])({
                                    organizationId,
                                    leadId,
                                    activityType: 'property_search',
                                    description: `Searched properties in ${sessionPreferences.location} under $${sessionPreferences.maxPrice?.toLocaleString()}`,
                                    metadata: {
                                        search_params: sessionPreferences
                                    }
                                });
                            }
                        } catch (crmError) {
                            console.error('❌ CRM sync error (non-critical):', crmError);
                        // Don't fail the request if CRM sync fails
                        }
                    }
                    // Send completion signal
                    controller.enqueue(encoder.encode('data: [DONE]\n\n'));
                    controller.close();
                } catch (error) {
                    console.error('❌ Streaming error:', error);
                    controller.error(error);
                }
            }
        });
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](readableStream, {
            headers: {
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache',
                Connection: 'keep-alive'
            }
        });
    } catch (error) {
        // Handle validation errors
        if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].ZodError) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Invalid request format',
                details: error.issues.map((e)=>({
                        path: e.path.join('.'),
                        message: e.message
                    }))
            }, {
                status: 400
            });
        }
        // Handle other errors
        console.error('❌ Chat API error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Internal server error'
        }, {
            status: 500
        });
    }
}
/**
 * Build enhanced system prompt with RAG context AND conversation state
 */ function buildEnhancedSystemPrompt(basePrompt, ragContext, sessionPreferences, extractedFields, canSearch) {
    const { searchResults, guidance } = ragContext;
    let enhancement = '\n\n## 🎯 CONTEXTUAL INTELLIGENCE\n\n';
    // Add conversation state awareness
    enhancement += `### 📊 Current Conversation State:\n\n`;
    if (Object.keys(sessionPreferences).length > 0) {
        enhancement += `**Information Already Collected:**\n`;
        if (sessionPreferences.location) enhancement += `- 📍 Location: ${sessionPreferences.location}\n`;
        if (sessionPreferences.maxPrice) enhancement += `- 💰 Budget: $${sessionPreferences.maxPrice.toLocaleString()}\n`;
        if (sessionPreferences.minBedrooms) enhancement += `- 🛏️ Bedrooms: ${sessionPreferences.minBedrooms}+\n`;
        if (sessionPreferences.minBathrooms) enhancement += `- 🛁 Bathrooms: ${sessionPreferences.minBathrooms}+\n`;
        if (sessionPreferences.propertyType) enhancement += `- 🏠 Type: ${sessionPreferences.propertyType}\n`;
        if (sessionPreferences.mustHaveFeatures && sessionPreferences.mustHaveFeatures.length > 0) {
            enhancement += `- ✨ Must-have features: ${sessionPreferences.mustHaveFeatures.join(', ')}\n`;
        }
        enhancement += '\n';
    }
    if (extractedFields.length > 0) {
        enhancement += `**Just Extracted from Last Message:** ${extractedFields.join(', ')}\n\n`;
    }
    // Search readiness
    if (canSearch) {
        enhancement += `🚀 **READY TO SEARCH!** You have location + budget. You can trigger a property search NOW by outputting the <property_search> format!\n\n`;
    } else {
        const missing = [];
        if (!sessionPreferences.location) missing.push('location');
        if (!sessionPreferences.maxPrice) missing.push('budget');
        if (missing.length > 0) {
            enhancement += `❌ **Cannot search yet.** Missing: ${missing.join(', ')}\n`;
            enhancement += `Ask for these naturally in your next response!\n\n`;
        }
    }
    // RAG-Enhanced Guidance
    if (searchResults.detectedProblems.length > 0) {
        enhancement += `### 💡 Similar Conversations:\n`;
        searchResults.detectedProblems.forEach((problem)=>{
            enhancement += `- ${problem}\n`;
        });
        enhancement += '\n';
    }
    if (guidance.suggestedApproach) {
        enhancement += `### 🎯 Recommended Approach:\n${guidance.suggestedApproach}\n\n`;
    }
    enhancement += `**REMEMBER:** Don't ask for information you already have! Reference it naturally instead.\n`;
    enhancement += `**REMEMBER:** If you can search now, do it! Don't keep asking unnecessary questions.\n`;
    return basePrompt + enhancement;
}
/**
 * Determine current conversation stage
 */ function determineConversationStage(messages) {
    const userMessages = messages.filter((m)=>m.role === 'user');
    if (userMessages.length <= 2) return 'discovery';
    if (userMessages.length <= 4) return 'qualifying';
    if (userMessages.length <= 6) return 'solutioning';
    return 'closing';
}
/**
 * Extract problems discussed so far
 */ function extractProblemsDiscussed(messages) {
    const problems = [];
    const problemKeywords = [
        'losing customers',
        'churn',
        'defects',
        'quality',
        'support tickets',
        'fraud',
        'maintenance',
        'inventory',
        // Real estate specific
        'looking for',
        'buy',
        'sell',
        'property',
        'home',
        'budget',
        'prequalified',
        'market'
    ];
    messages.forEach((message)=>{
        const content = message.content.toLowerCase();
        problemKeywords.forEach((keyword)=>{
            if (content.includes(keyword) && !problems.includes(keyword)) {
                problems.push(keyword);
            }
        });
    });
    return problems;
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__5174c444._.js.map